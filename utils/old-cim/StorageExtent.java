/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Wed Jan 12
 * 09:21:06 CET 2011.
 */

package org.opennaas.extensions.router.model;

import java.io.Serializable;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class StorageExtent as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the StorageExtentBean Interface. The CIM class StorageExtent is described as follows:
 * 
 * StorageExtent describes the capabilities and management of the various media that exist to store data and allow data retrieval. This superclass
 * could be used to represent the various components of RAID (Hardware or Software) or as a raw logical extent on top of physical media.
 */
public class StorageExtent extends LogicalDevice implements Serializable {

	/**
	 * This constructor creates a StorageExtentBeanImpl Class which implements the StorageExtentBean Interface, and encapsulates the CIM class
	 * StorageExtent in a Java Bean. The CIM class StorageExtent is described as follows:
	 * 
	 * StorageExtent describes the capabilities and management of the various media that exist to store data and allow data retrieval. This superclass
	 * could be used to represent the various components of RAID (Hardware or Software) or as a raw logical extent on top of physical media.
	 */
	public StorageExtent() {
	};

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property DataOrganization.
	 */

	public enum DataOrganization {
		OTHER,
		UNKNOWN,
		FIXED_BLOCK,
		VARIABLE_BLOCK,
		COUNT_KEY_DATA
	}

	private DataOrganization	dataOrganization;

	/**
	 * This method returns the StorageExtent.dataOrganization property value. This property is described as follows:
	 * 
	 * Type of data organization used.
	 * 
	 * @return int current dataOrganization property value
	 * @exception Exception
	 */
	public DataOrganization getDataOrganization() {

		return this.dataOrganization;
	} // getDataOrganization

	/**
	 * This method sets the StorageExtent.dataOrganization property value. This property is described as follows:
	 * 
	 * Type of data organization used.
	 * 
	 * @param int new dataOrganization property value
	 * @exception Exception
	 */
	public void setDataOrganization(DataOrganization dataOrganization) {

		this.dataOrganization = dataOrganization;
	} // setDataOrganization

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property purpose.
	 */
	private String	purpose;

	/**
	 * This method returns the StorageExtent.purpose property value. This property is described as follows:
	 * 
	 * A free form string describing the media and/or its use.
	 * 
	 * @return String current purpose property value
	 * @exception Exception
	 */
	public String getPurpose() {

		return this.purpose;
	} // getPurpose

	/**
	 * This method sets the StorageExtent.purpose property value. This property is described as follows:
	 * 
	 * A free form string describing the media and/or its use.
	 * 
	 * @param String
	 *            new purpose property value
	 * @exception Exception
	 */
	public void setPurpose(String purpose) {

		this.purpose = purpose;
	} // setPurpose

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property Access.
	 */

	public enum Access {
		UNKNOWN,
		READABLE,
		WRITEABLE,
		READ_WRITE_SUPPORTED,
		WRITE_ONCE
	}

	private Access	access;

	/**
	 * This method returns the StorageExtent.access property value. This property is described as follows:
	 * 
	 * Access describes whether the media is readable (value=1), writeable (value=2), or both (value=3). "Unknown" (0) and "Write Once" (4) can also
	 * be defined.
	 * 
	 * @return int current access property value
	 * @exception Exception
	 */
	public Access getAccess() {

		return this.access;
	} // getAccess

	/**
	 * This method sets the StorageExtent.access property value. This property is described as follows:
	 * 
	 * Access describes whether the media is readable (value=1), writeable (value=2), or both (value=3). "Unknown" (0) and "Write Once" (4) can also
	 * be defined.
	 * 
	 * @param int new access property value
	 * @exception Exception
	 */
	public void setAccess(Access access) {

		this.access = access;
	} // setAccess

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property errorMethodology.
	 */
	private String	errorMethodology;

	/**
	 * This method returns the StorageExtent.errorMethodology property value. This property is described as follows:
	 * 
	 * ErrorMethodology is a free-form string describing the type of error detection and correction supported by this StorageExtent.
	 * 
	 * @return String current errorMethodology property value
	 * @exception Exception
	 */
	public String getErrorMethodology() {

		return this.errorMethodology;
	} // getErrorMethodology

	/**
	 * This method sets the StorageExtent.errorMethodology property value. This property is described as follows:
	 * 
	 * ErrorMethodology is a free-form string describing the type of error detection and correction supported by this StorageExtent.
	 * 
	 * @param String
	 *            new errorMethodology property value
	 * @exception Exception
	 */
	public void setErrorMethodology(String errorMethodology) {

		this.errorMethodology = errorMethodology;
	} // setErrorMethodology

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property blockSize.
	 */
	private long	blockSize;

	/**
	 * This method returns the StorageExtent.blockSize property value. This property is described as follows:
	 * 
	 * Size in bytes of the blocks which form this StorageExtent. If variable block size, then the maximum block size in bytes should be specified. If
	 * the block size is unknown or if a block concept is not valid (for example, for AggregateExtents, Memory or LogicalDisks), enter a 1.
	 * 
	 * @return long current blockSize property value
	 * @exception Exception
	 */
	public long getBlockSize() {

		return this.blockSize;
	} // getBlockSize

	/**
	 * This method sets the StorageExtent.blockSize property value. This property is described as follows:
	 * 
	 * Size in bytes of the blocks which form this StorageExtent. If variable block size, then the maximum block size in bytes should be specified. If
	 * the block size is unknown or if a block concept is not valid (for example, for AggregateExtents, Memory or LogicalDisks), enter a 1.
	 * 
	 * @param long new blockSize property value
	 * @exception Exception
	 */
	public void setBlockSize(long blockSize) {

		this.blockSize = blockSize;
	} // setBlockSize

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property numberOfBlocks.
	 */
	private long	numberOfBlocks;

	/**
	 * This method returns the StorageExtent.numberOfBlocks property value. This property is described as follows:
	 * 
	 * Total number of logically contiguous blocks, of size Block Size, which form this Extent. The total size of the Extent can be calculated by
	 * multiplying BlockSize by NumberOfBlocks. If the BlockSize is 1, this property is the total size of the Extent.
	 * 
	 * @return long current numberOfBlocks property value
	 * @exception Exception
	 */
	public long getNumberOfBlocks() {

		return this.numberOfBlocks;
	} // getNumberOfBlocks

	/**
	 * This method sets the StorageExtent.numberOfBlocks property value. This property is described as follows:
	 * 
	 * Total number of logically contiguous blocks, of size Block Size, which form this Extent. The total size of the Extent can be calculated by
	 * multiplying BlockSize by NumberOfBlocks. If the BlockSize is 1, this property is the total size of the Extent.
	 * 
	 * @param long new numberOfBlocks property value
	 * @exception Exception
	 */
	public void setNumberOfBlocks(long numberOfBlocks) {

		this.numberOfBlocks = numberOfBlocks;
	} // setNumberOfBlocks

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property consumableBlocks.
	 */
	private long	consumableBlocks;

	/**
	 * This method returns the StorageExtent.consumableBlocks property value. This property is described as follows:
	 * 
	 * The maximum number of blocks, of size BlockSize, which are available for consumption when layering StorageExtents using the BasedOn
	 * association. This property only has meaning when this StorageExtent is an Antecedent reference in a BasedOn relationship. For example, a
	 * StorageExtent could be composed of 120 blocks. However, the Extent itself may use 20 blocks for redundancy data. If another StorageExtent is
	 * BasedOn this Extent, only 100 blocks would be available to it. This information ('100 blocks is available for consumption') is indicated in the
	 * ConsumableBlocks property.
	 * 
	 * @return long current consumableBlocks property value
	 * @exception Exception
	 */
	public long getConsumableBlocks() {

		return this.consumableBlocks;
	} // getConsumableBlocks

	/**
	 * This method sets the StorageExtent.consumableBlocks property value. This property is described as follows:
	 * 
	 * The maximum number of blocks, of size BlockSize, which are available for consumption when layering StorageExtents using the BasedOn
	 * association. This property only has meaning when this StorageExtent is an Antecedent reference in a BasedOn relationship. For example, a
	 * StorageExtent could be composed of 120 blocks. However, the Extent itself may use 20 blocks for redundancy data. If another StorageExtent is
	 * BasedOn this Extent, only 100 blocks would be available to it. This information ('100 blocks is available for consumption') is indicated in the
	 * ConsumableBlocks property.
	 * 
	 * @param long new consumableBlocks property value
	 * @exception Exception
	 */
	public void setConsumableBlocks(long consumableBlocks) {

		this.consumableBlocks = consumableBlocks;
	} // setConsumableBlocks

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property isBasedOnUnderlyingRedundancy.
	 */
	private boolean	isBasedOnUnderlyingRedundancy;

	/**
	 * This method returns the StorageExtent.isBasedOnUnderlyingRedundancy property value. This property is described as follows:
	 * 
	 * True indicates that the underlying StorageExtent(s) participate in a StorageRedundancyGroup.
	 * 
	 * @return boolean current isBasedOnUnderlyingRedundancy property value
	 * @exception Exception
	 */
	public boolean isIsBasedOnUnderlyingRedundancy() {

		return this.isBasedOnUnderlyingRedundancy;
	} // getIsBasedOnUnderlyingRedundancy

	/**
	 * This method sets the StorageExtent.isBasedOnUnderlyingRedundancy property value. This property is described as follows:
	 * 
	 * True indicates that the underlying StorageExtent(s) participate in a StorageRedundancyGroup.
	 * 
	 * @param boolean new isBasedOnUnderlyingRedundancy property value
	 * @exception Exception
	 */
	public void setIsBasedOnUnderlyingRedundancy(boolean
			isBasedOnUnderlyingRedundancy) {

		this.isBasedOnUnderlyingRedundancy = isBasedOnUnderlyingRedundancy;
	} // setIsBasedOnUnderlyingRedundancy

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property sequentialAccess.
	 */
	private boolean	sequentialAccess;

	/**
	 * This method returns the StorageExtent.sequentialAccess property value. This property is described as follows:
	 * 
	 * Boolean set to TRUE if the Storage is sequentially accessed by a MediaAccessDevice. A TapePartition is an example of a sequentially accessed
	 * StorageExtent. StorageVolumes, Disk Partitions and LogicalDisks represent randomly accessed Extents.
	 * 
	 * @return boolean current sequentialAccess property value
	 * @exception Exception
	 */
	public boolean isSequentialAccess() {

		return this.sequentialAccess;
	} // getSequentialAccess

	/**
	 * This method sets the StorageExtent.sequentialAccess property value. This property is described as follows:
	 * 
	 * Boolean set to TRUE if the Storage is sequentially accessed by a MediaAccessDevice. A TapePartition is an example of a sequentially accessed
	 * StorageExtent. StorageVolumes, Disk Partitions and LogicalDisks represent randomly accessed Extents.
	 * 
	 * @param boolean new sequentialAccess property value
	 * @exception Exception
	 */
	public void setSequentialAccess(boolean sequentialAccess) {

		this.sequentialAccess = sequentialAccess;
	} // setSequentialAccess

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property ExtentStatus.
	 */

	public enum ExtentStatus {
		OTHER,
		UNKNOWN,
		NONE_NOT_APPLICABLE,
		BROKEN,
		DATA_LOST,
		DYNAMIC_RECONFIG,
		EXPOSED,
		FRACTIONALLY_EXPOSED,
		PARTIALLY_EXPOSED,
		PROTECTION_DISABLED,
		READYING,
		REBUILD,
		RECALCULATE,
		SPARE_IN_USE,
		VERIFY_IN_PROGRESS,
		IN_BAND_ACCESS_GRANTED,
		IMPORTED,
		EXPORTED,
		DMTF_RESERVED,
		VENDOR_RESERVED
	}

	private ExtentStatus	extentStatus;

	/**
	 * This method returns the StorageExtent.extentStatus property value. This property is described as follows:
	 * 
	 * StorageExtents have additional status information beyond that captured in the OperationalStatus and other properties, inherited from
	 * ManagedSystemElement. This additional information (for example, "Protection Disabled", value=9) is captured in the ExtentStatus property.
	 * 'In-Band Access Granted' says that access to data on an extent is granted to some consumer and is only valid when 'Exported' is also set. It is
	 * set as a side effect of PrivilegeManagementService.ChangeAccess or equivalent interfaces. 'Imported' indicates that the extent is used in the
	 * current system, but known to be managed by some other system. For example, a server imports volumes from a disk array. 'Exported' indicates the
	 * extent is meant to be used by some comsumer. A disk array's logical units are exported. Intermediate composite extents may be neither imported
	 * nor exported.
	 * 
	 * @return int current extentStatus property value
	 * @exception Exception
	 */
	public ExtentStatus getExtentStatus() {

		return this.extentStatus;
	} // getExtentStatus

	/**
	 * This method sets the StorageExtent.extentStatus property value. This property is described as follows:
	 * 
	 * StorageExtents have additional status information beyond that captured in the OperationalStatus and other properties, inherited from
	 * ManagedSystemElement. This additional information (for example, "Protection Disabled", value=9) is captured in the ExtentStatus property.
	 * 'In-Band Access Granted' says that access to data on an extent is granted to some consumer and is only valid when 'Exported' is also set. It is
	 * set as a side effect of PrivilegeManagementService.ChangeAccess or equivalent interfaces. 'Imported' indicates that the extent is used in the
	 * current system, but known to be managed by some other system. For example, a server imports volumes from a disk array. 'Exported' indicates the
	 * extent is meant to be used by some comsumer. A disk array's logical units are exported. Intermediate composite extents may be neither imported
	 * nor exported.
	 * 
	 * @param int new extentStatus property value
	 * @exception Exception
	 */
	public void setExtentStatus(ExtentStatus extentStatus) {

		this.extentStatus = extentStatus;
	} // setExtentStatus

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property noSinglePointOfFailure.
	 */
	private boolean	noSinglePointOfFailure;

	/**
	 * This method returns the StorageExtent.noSinglePointOfFailure property value. This property is described as follows:
	 * 
	 * Indicates whether or not there exists no single point of failure.
	 * 
	 * @return boolean current noSinglePointOfFailure property value
	 * @exception Exception
	 */
	public boolean isNoSinglePointOfFailure() {

		return this.noSinglePointOfFailure;
	} // getNoSinglePointOfFailure

	/**
	 * This method sets the StorageExtent.noSinglePointOfFailure property value. This property is described as follows:
	 * 
	 * Indicates whether or not there exists no single point of failure.
	 * 
	 * @param boolean new noSinglePointOfFailure property value
	 * @exception Exception
	 */
	public void setNoSinglePointOfFailure(boolean noSinglePointOfFailure) {

		this.noSinglePointOfFailure = noSinglePointOfFailure;
	} // setNoSinglePointOfFailure

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property dataRedundancy.
	 */
	private int	dataRedundancy;

	/**
	 * This method returns the StorageExtent.dataRedundancy property value. This property is described as follows:
	 * 
	 * Number of complete copies of data currently maintained.
	 * 
	 * @return int current dataRedundancy property value
	 * @exception Exception
	 */
	public int getDataRedundancy() {

		return this.dataRedundancy;
	} // getDataRedundancy

	/**
	 * This method sets the StorageExtent.dataRedundancy property value. This property is described as follows:
	 * 
	 * Number of complete copies of data currently maintained.
	 * 
	 * @param int new dataRedundancy property value
	 * @exception Exception
	 */
	public void setDataRedundancy(int dataRedundancy) {

		this.dataRedundancy = dataRedundancy;
	} // setDataRedundancy

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property packageRedundancy.
	 */
	private int	packageRedundancy;

	/**
	 * This method returns the StorageExtent.packageRedundancy property value. This property is described as follows:
	 * 
	 * How many physical packages can currently fail without data loss. For example, in the storage domain, this might be disk spindles.
	 * 
	 * @return int current packageRedundancy property value
	 * @exception Exception
	 */
	public int getPackageRedundancy() {

		return this.packageRedundancy;
	} // getPackageRedundancy

	/**
	 * This method sets the StorageExtent.packageRedundancy property value. This property is described as follows:
	 * 
	 * How many physical packages can currently fail without data loss. For example, in the storage domain, this might be disk spindles.
	 * 
	 * @param int new packageRedundancy property value
	 * @exception Exception
	 */
	public void setPackageRedundancy(int packageRedundancy) {

		this.packageRedundancy = packageRedundancy;
	} // setPackageRedundancy

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property deltaReservation.
	 */
	private short	deltaReservation;

	/**
	 * This method returns the StorageExtent.deltaReservation property value. This property is described as follows:
	 * 
	 * Current value for Delta reservation. This is a percentage that specifies the amount of space that should be reserved in a replica for caching
	 * changes.
	 * 
	 * @return short current deltaReservation property value
	 * @exception Exception
	 */
	public short getDeltaReservation() {

		return this.deltaReservation;
	} // getDeltaReservation

	/**
	 * This method sets the StorageExtent.deltaReservation property value. This property is described as follows:
	 * 
	 * Current value for Delta reservation. This is a percentage that specifies the amount of space that should be reserved in a replica for caching
	 * changes.
	 * 
	 * @param short new deltaReservation property value
	 * @exception Exception
	 */
	public void setDeltaReservation(short deltaReservation) {

		this.deltaReservation = deltaReservation;
	} // setDeltaReservation

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property primordial.
	 */
	private boolean	primordial;

	/**
	 * This method returns the StorageExtent.primordial property value. This property is described as follows:
	 * 
	 * If true, "Primordial" indicates that the containing System does not have the ability to create or delete this operational element. This is
	 * important because StorageExtents are assembled into higher-level abstractions using the BasedOn association. Although the higher-level
	 * abstractions can be created and deleted, the most basic, (i.e. primordial), hardware-based storage entities cannot. They are physically
	 * realized as part of the System, or are actually managed by some other System and imported as if they were physically realized. In other words,
	 * a Primordial StorageExtent exists in, but is not created by its System and conversely a non-Primordial StorageExtent is created in the context
	 * of its System. For StorageVolumes, this property will generally be false. One use of this property is to enable algorithms that aggregate
	 * StorageExtent.ConsumableSpace across all, StorageExtents but that also want to distinquish the space that underlies Primordial StoragePools.
	 * Since implementations are not required to surface all Component StorageExtents of a StoragePool, this information is not accessible in any
	 * other way.
	 * 
	 * @return boolean current primordial property value
	 * @exception Exception
	 */
	public boolean isPrimordial() {

		return this.primordial;
	} // getPrimordial

	/**
	 * This method sets the StorageExtent.primordial property value. This property is described as follows:
	 * 
	 * If true, "Primordial" indicates that the containing System does not have the ability to create or delete this operational element. This is
	 * important because StorageExtents are assembled into higher-level abstractions using the BasedOn association. Although the higher-level
	 * abstractions can be created and deleted, the most basic, (i.e. primordial), hardware-based storage entities cannot. They are physically
	 * realized as part of the System, or are actually managed by some other System and imported as if they were physically realized. In other words,
	 * a Primordial StorageExtent exists in, but is not created by its System and conversely a non-Primordial StorageExtent is created in the context
	 * of its System. For StorageVolumes, this property will generally be false. One use of this property is to enable algorithms that aggregate
	 * StorageExtent.ConsumableSpace across all, StorageExtents but that also want to distinquish the space that underlies Primordial StoragePools.
	 * Since implementations are not required to surface all Component StorageExtents of a StoragePool, this information is not accessible in any
	 * other way.
	 * 
	 * @param boolean new primordial property value
	 * @exception Exception
	 */
	public void setPrimordial(boolean primordial) {

		this.primordial = primordial;
	} // setPrimordial

	// /**
	// * The following constants are defined for use with the ValueMap/Values
	// * qualified property name.
	// */
	// private String name;
	/**
	 * This method returns the StorageExtent.name property value. This property is described as follows:
	 * 
	 * A unique identifier for the Extent.
	 * 
	 * @return String current name property value
	 * @exception Exception
	 */
	@Override
	public String getName() {

		return super.getName();
	} // getName

	/**
	 * This method sets the StorageExtent.name property value. This property is described as follows:
	 * 
	 * A unique identifier for the Extent.
	 * 
	 * @param String
	 *            new name property value
	 * @exception Exception
	 */
	@Override
	public void setName(String name) {

		super.setName(name);
	} // setName

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property NameFormat.
	 */

	public enum NameFormat {
		UNKNOWN,
		OTHER,
		VPD83NAA6,
		VPD83NAA5,
		VPD83TYPE2,
		VPD83TYPE1,
		VPD83TYPE0,
		SNVM,
		NODEWWN,
		NAA,
		EUI64,
		T10VID,
		OS_DEVICE_NAME
	}

	private NameFormat	nameFormat;

	/**
	 * This method returns the StorageExtent.nameFormat property value. This property is described as follows:
	 * 
	 * The list here applies to all StorageExtent subclasses. Please look at the Description in each subclass for guidelines on the approriate values
	 * for that subclass. Note that any of these formats could apply to a CompositeExtent. Note - this property originally touched on two concepts
	 * that are now separated into this property and NameNamespace. Values 2,3,4,5,6, and 8 are retained for backwards compatibility but are
	 * deprecated in lieu of the corresponding values in CIM_StorageExtent.NameNamespace. For example, the preferred source for SCSI virtual (RAID)
	 * disk names is from Inquiry VPD page 83 response, type 3 identifiers. These will have NameFormat set to 'NAA' and NameNamespace to 'VPD83Type3'.
	 * Format of the Name property. Values for extents representing SCSI volumes are (per SCSI SPC-3): 2 = VPD Page 83, NAA IEEE Registered Extended
	 * (VPD83NAA6) (DEPRECATED) 3 = VPD Page 83, NAA IEEE Registered (VPD83NAA5) (DEPRECATED) 4 = VPD Page 83, (VPD83Type2) (DEPRECATED) 5 = VPD Page
	 * 83, T10 Vendor Identification (VPD83Type1) (DEPRECATED) 6 = VPD Page 83, Vendor Specific (VPD83Type0) (DEPRECATED) 7 = Serial
	 * Number/Vendor/Model (SNVM) SNVM is 3 strings representing the vendor name, product name within the vendor namespace, and the serial number
	 * within the model namespace. Strings are delimited with a '+'. Spaces may be included and are significant. The serial number is the text
	 * representation of the serial number in hexadecimal upper case. This represents the vendor and model ID from SCSI Inquiry data; the vendor field
	 * MUST be 8 characters wide and the product field MUST be 16 characters wide. For example, 'ACME____+SUPER DISK______+124437458' (_ is a space
	 * character) 8 = Node WWN (for single LUN/controller) (NodeWWN) (DEPRECATED) 9 = NAA as a generic format. See
	 * http://standards.ieee.org/regauth/oui/tutorials/fibrecomp_id.html. Formatted as 16 or 32 unseparated uppercase hex characters (2 per binary
	 * byte). For example '21000020372D3C73' 10 = EUI as a generic format (EUI64) See http://standards.ieee.org/regauth/oui/tutorials/EUI64.html.
	 * Formatted as 16 unseparated uppercase hex characters (2 per binary byte) 11 = T10 vendor identifier format as returned by SCSI Inquiry VPD page
	 * 83, identifier type 1. See T10 SPC-3 specification. This is the 8-byte ASCII vendor ID from the T10 registry followed by a vendor specific
	 * ASCII identifier; spaces are permitted. For non SCSI volumes, 'SNVM' may be the most appropriate choice. 12 = OS Device Name (for
	 * LogicalDisks). See LogicalDisk Name description for details.
	 * 
	 * @return int current nameFormat property value
	 * @exception Exception
	 */
	public NameFormat getNameFormat() {

		return this.nameFormat;
	} // getNameFormat

	/**
	 * This method sets the StorageExtent.nameFormat property value. This property is described as follows:
	 * 
	 * The list here applies to all StorageExtent subclasses. Please look at the Description in each subclass for guidelines on the approriate values
	 * for that subclass. Note that any of these formats could apply to a CompositeExtent. Note - this property originally touched on two concepts
	 * that are now separated into this property and NameNamespace. Values 2,3,4,5,6, and 8 are retained for backwards compatibility but are
	 * deprecated in lieu of the corresponding values in CIM_StorageExtent.NameNamespace. For example, the preferred source for SCSI virtual (RAID)
	 * disk names is from Inquiry VPD page 83 response, type 3 identifiers. These will have NameFormat set to 'NAA' and NameNamespace to 'VPD83Type3'.
	 * Format of the Name property. Values for extents representing SCSI volumes are (per SCSI SPC-3): 2 = VPD Page 83, NAA IEEE Registered Extended
	 * (VPD83NAA6) (DEPRECATED) 3 = VPD Page 83, NAA IEEE Registered (VPD83NAA5) (DEPRECATED) 4 = VPD Page 83, (VPD83Type2) (DEPRECATED) 5 = VPD Page
	 * 83, T10 Vendor Identification (VPD83Type1) (DEPRECATED) 6 = VPD Page 83, Vendor Specific (VPD83Type0) (DEPRECATED) 7 = Serial
	 * Number/Vendor/Model (SNVM) SNVM is 3 strings representing the vendor name, product name within the vendor namespace, and the serial number
	 * within the model namespace. Strings are delimited with a '+'. Spaces may be included and are significant. The serial number is the text
	 * representation of the serial number in hexadecimal upper case. This represents the vendor and model ID from SCSI Inquiry data; the vendor field
	 * MUST be 8 characters wide and the product field MUST be 16 characters wide. For example, 'ACME____+SUPER DISK______+124437458' (_ is a space
	 * character) 8 = Node WWN (for single LUN/controller) (NodeWWN) (DEPRECATED) 9 = NAA as a generic format. See
	 * http://standards.ieee.org/regauth/oui/tutorials/fibrecomp_id.html. Formatted as 16 or 32 unseparated uppercase hex characters (2 per binary
	 * byte). For example '21000020372D3C73' 10 = EUI as a generic format (EUI64) See http://standards.ieee.org/regauth/oui/tutorials/EUI64.html.
	 * Formatted as 16 unseparated uppercase hex characters (2 per binary byte) 11 = T10 vendor identifier format as returned by SCSI Inquiry VPD page
	 * 83, identifier type 1. See T10 SPC-3 specification. This is the 8-byte ASCII vendor ID from the T10 registry followed by a vendor specific
	 * ASCII identifier; spaces are permitted. For non SCSI volumes, 'SNVM' may be the most appropriate choice. 12 = OS Device Name (for
	 * LogicalDisks). See LogicalDisk Name description for details.
	 * 
	 * @param int new nameFormat property value
	 * @exception Exception
	 */
	public void setNameFormat(NameFormat nameFormat) {

		this.nameFormat = nameFormat;
	} // setNameFormat

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property NameNamespace.
	 */

	public enum NameNamespace {
		UNKNOWN,
		OTHER,
		VPD83TYPE3,
		VPD83TYPE2,
		VPD83TYPE1,
		VPD80,
		NODEWWN,
		SNVM,
		OS_DEVICE_NAMESPACE
	}

	private NameNamespace	nameNamespace;

	/**
	 * This method returns the StorageExtent.nameNamespace property value. This property is described as follows:
	 * 
	 * The preferred source SCSI for volume names is SCSI VPD Page 83 responses. Page 83 returns a list of identifiers for various device elements.
	 * The metadata for each identifier includes an Association field, identifiers with association of 0 apply to volumes. Page 83 supports several
	 * namespaces specified in the Type field in the identifier metadata. See SCSI SPC-3 specification. 2 = VPD Page 83, Type 3 NAA (NameFormat SHOULD
	 * be NAA) 3 = VPD Page 83, Type 2 EUI64 (NameFormat EUI) 4 = VPD Page 83, Type 1 T10 Vendor Identification (NameFormat T10) Less preferred volume
	 * namespaces from other interfaces: 5 = VPD page 80, Serial number (NameFormat SHOULD be Other) 6 = FC NodeWWN (NameFormat SHOULD be NAA or EUI)
	 * 7 = Serial Number/Vendor/Model (NameFormat SHOULD be SNVM) The preferred namespace for LogigicalDisk names is platform specific device
	 * namespace; see LogigicalDIsk Description. 8 = OS Device Namespace.
	 * 
	 * @return int current nameNamespace property value
	 * @exception Exception
	 */
	public NameNamespace getNameNamespace() {

		return this.nameNamespace;
	} // getNameNamespace

	/**
	 * This method sets the StorageExtent.nameNamespace property value. This property is described as follows:
	 * 
	 * The preferred source SCSI for volume names is SCSI VPD Page 83 responses. Page 83 returns a list of identifiers for various device elements.
	 * The metadata for each identifier includes an Association field, identifiers with association of 0 apply to volumes. Page 83 supports several
	 * namespaces specified in the Type field in the identifier metadata. See SCSI SPC-3 specification. 2 = VPD Page 83, Type 3 NAA (NameFormat SHOULD
	 * be NAA) 3 = VPD Page 83, Type 2 EUI64 (NameFormat EUI) 4 = VPD Page 83, Type 1 T10 Vendor Identification (NameFormat T10) Less preferred volume
	 * namespaces from other interfaces: 5 = VPD page 80, Serial number (NameFormat SHOULD be Other) 6 = FC NodeWWN (NameFormat SHOULD be NAA or EUI)
	 * 7 = Serial Number/Vendor/Model (NameFormat SHOULD be SNVM) The preferred namespace for LogigicalDisk names is platform specific device
	 * namespace; see LogigicalDIsk Description. 8 = OS Device Namespace.
	 * 
	 * @param int new nameNamespace property value
	 * @exception Exception
	 */
	public void setNameNamespace(NameNamespace nameNamespace) {

		this.nameNamespace = nameNamespace;
	} // setNameNamespace

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property otherNameNamespace.
	 */
	private String	otherNameNamespace;

	/**
	 * This method returns the StorageExtent.otherNameNamespace property value. This property is described as follows:
	 * 
	 * A string describing the namespace of the Name property when NameNamespace includes the value 1, "Other".
	 * 
	 * @return String current otherNameNamespace property value
	 * @exception Exception
	 */
	public String getOtherNameNamespace() {

		return this.otherNameNamespace;
	} // getOtherNameNamespace

	/**
	 * This method sets the StorageExtent.otherNameNamespace property value. This property is described as follows:
	 * 
	 * A string describing the namespace of the Name property when NameNamespace includes the value 1, "Other".
	 * 
	 * @param String
	 *            new otherNameNamespace property value
	 * @exception Exception
	 */
	public void setOtherNameNamespace(String otherNameNamespace) {

		this.otherNameNamespace = otherNameNamespace;
	} // setOtherNameNamespace

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property otherNameFormat.
	 */
	private String	otherNameFormat;

	/**
	 * This method returns the StorageExtent.otherNameFormat property value. This property is described as follows:
	 * 
	 * A string describing the format of the Name property when NameFormat includes the value 1, "Other".
	 * 
	 * @return String current otherNameFormat property value
	 * @exception Exception
	 */
	public String getOtherNameFormat() {

		return this.otherNameFormat;
	} // getOtherNameFormat

	/**
	 * This method sets the StorageExtent.otherNameFormat property value. This property is described as follows:
	 * 
	 * A string describing the format of the Name property when NameFormat includes the value 1, "Other".
	 * 
	 * @param String
	 *            new otherNameFormat property value
	 * @exception Exception
	 */
	public void setOtherNameFormat(String otherNameFormat) {

		this.otherNameFormat = otherNameFormat;
	} // setOtherNameFormat

} // Class StorageExtent
