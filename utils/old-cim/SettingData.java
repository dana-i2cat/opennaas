/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Wed Jan 12
 * 09:21:06 CET 2011.
 */

package org.opennaas.extensions.router.model;

import java.io.*;
import java.lang.Exception;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class SettingData as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the SettingDataBean Interface. The CIM class SettingData is described as follows:
 * 
 * CIM_SettingData is used to represent configuration and and operational parameters for CIM_ManagedElement instances. There are a number of different
 * uses of CIM_SettingData supported in the model today. Additional uses may be defined in the future. Instances of CIM_SettingData may represent
 * Aspects of a CIM_ManagedElement instance. This is modeled using the CIM_SettingsDefineState association. CIM_SettingData may be used to define
 * capabilities when associated to an instance of CIM_Capabilities through the CIM_SettingsDefineCapabilities association. Instances of
 * CIM_SettingData may represent different types of configurations for a CIM_ManagedElement, including persistent configurations, in progress
 * configuration changes, or requested configurations. The CIM_ElementSettingData association is used to model the relationship between a
 * CIM_SettingData instance and the CIM_ManagedElement for which it is a configuration. When an instance of CIM_SettingData represents a
 * configuration, the current operational values for the parameters of the element are reflected by properties in the Element itself or by properties
 * in its associations. These properties do not have to be the same values that are present in the SettingData object. For example, a modem might have
 * a SettingData baud rate of 56Kb/sec but be operating at 19.2Kb/sec. Note: The CIM_SettingData class is very similar to CIM_Setting, yet both
 * classes are present in the model because many implementations have successfully used CIM_Setting. However, issues have arisen that could not be
 * resolved without defining a new class. Therefore, until a new major release occurs, both classes will exist in the model. Refer to the Core White
 * Paper for additional information. SettingData instances can be aggregated together into higher- level SettingData objects using ConcreteComponent
 * associations.
 */
public class SettingData extends ManagedElement implements Serializable {

	/**
	 * This constructor creates a SettingDataBeanImpl Class which implements the SettingDataBean Interface, and encapsulates the CIM class SettingData
	 * in a Java Bean. The CIM class SettingData is described as follows:
	 * 
	 * CIM_SettingData is used to represent configuration and and operational parameters for CIM_ManagedElement instances. There are a number of
	 * different uses of CIM_SettingData supported in the model today. Additional uses may be defined in the future. Instances of CIM_SettingData may
	 * represent Aspects of a CIM_ManagedElement instance. This is modeled using the CIM_SettingsDefineState association. CIM_SettingData may be used
	 * to define capabilities when associated to an instance of CIM_Capabilities through the CIM_SettingsDefineCapabilities association. Instances of
	 * CIM_SettingData may represent different types of configurations for a CIM_ManagedElement, including persistent configurations, in progress
	 * configuration changes, or requested configurations. The CIM_ElementSettingData association is used to model the relationship between a
	 * CIM_SettingData instance and the CIM_ManagedElement for which it is a configuration. When an instance of CIM_SettingData represents a
	 * configuration, the current operational values for the parameters of the element are reflected by properties in the Element itself or by
	 * properties in its associations. These properties do not have to be the same values that are present in the SettingData object. For example, a
	 * modem might have a SettingData baud rate of 56Kb/sec but be operating at 19.2Kb/sec. Note: The CIM_SettingData class is very similar to
	 * CIM_Setting, yet both classes are present in the model because many implementations have successfully used CIM_Setting. However, issues have
	 * arisen that could not be resolved without defining a new class. Therefore, until a new major release occurs, both classes will exist in the
	 * model. Refer to the Core White Paper for additional information. SettingData instances can be aggregated together into higher- level
	 * SettingData objects using ConcreteComponent associations.
	 */
	protected SettingData() {
	};

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property instanceID.
	 */
	private String	instanceID;

	/**
	 * This method returns the SettingData.instanceID property value. This property is described as follows:
	 * 
	 * Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. To ensure uniqueness
	 * within the NameSpace, the value of InstanceID should be constructed using the following "preferred" algorithm: <OrgID>:<LocalID> Where <OrgID>
	 * and <LocalID> are separated by a colon (:), and where <OrgID> must include a copyrighted, trademarked, or otherwise unique name that is owned
	 * by the business entity that is creating or defining the InstanceID or that is a registered ID assigned to the business entity by a recognized
	 * global authority. (This requirement is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure
	 * uniqueness, <OrgID> must not contain a colon (:). When using this algorithm, the first colon to appear in InstanceID must appear between
	 * <OrgID> and <LocalID>. <LocalID> is chosen by the business entity and should not be reused to identify different underlying (real-world)
	 * elements. If the above "preferred" algorithm is not used, the defining entity must assure that the resulting InstanceID is not reused across
	 * any InstanceIDs produced by this or other providers for the NameSpace of this instance. For DMTF-defined instances, the "preferred" algorithm
	 * must be used with the <OrgID> set to CIM.
	 * 
	 * @return String current instanceID property value
	 * @exception Exception
	 */
	@Override
	public String getInstanceID() {

		return this.instanceID;
	} // getInstanceID

	/**
	 * This method sets the SettingData.instanceID property value. This property is described as follows:
	 * 
	 * Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. To ensure uniqueness
	 * within the NameSpace, the value of InstanceID should be constructed using the following "preferred" algorithm: <OrgID>:<LocalID> Where <OrgID>
	 * and <LocalID> are separated by a colon (:), and where <OrgID> must include a copyrighted, trademarked, or otherwise unique name that is owned
	 * by the business entity that is creating or defining the InstanceID or that is a registered ID assigned to the business entity by a recognized
	 * global authority. (This requirement is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure
	 * uniqueness, <OrgID> must not contain a colon (:). When using this algorithm, the first colon to appear in InstanceID must appear between
	 * <OrgID> and <LocalID>. <LocalID> is chosen by the business entity and should not be reused to identify different underlying (real-world)
	 * elements. If the above "preferred" algorithm is not used, the defining entity must assure that the resulting InstanceID is not reused across
	 * any InstanceIDs produced by this or other providers for the NameSpace of this instance. For DMTF-defined instances, the "preferred" algorithm
	 * must be used with the <OrgID> set to CIM.
	 * 
	 * @param String
	 *            new instanceID property value
	 * @exception Exception
	 */
	@Override
	public void setInstanceID(String instanceID) {

		this.instanceID = instanceID;
	} // setInstanceID

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property elementName.
	 */
	private String	elementName;

	/**
	 * This method returns the SettingData.elementName property value. This property is described as follows:
	 * 
	 * The user-friendly name for this instance of SettingData. In addition, the user-friendly name can be used as an index property for a search or
	 * query. (Note: The name does not have to be unique within a namespace.)
	 * 
	 * @return String current elementName property value
	 * @exception Exception
	 */
	@Override
	public String getElementName() {

		return this.elementName;
	} // getElementName

	/**
	 * This method sets the SettingData.elementName property value. This property is described as follows:
	 * 
	 * The user-friendly name for this instance of SettingData. In addition, the user-friendly name can be used as an index property for a search or
	 * query. (Note: The name does not have to be unique within a namespace.)
	 * 
	 * @param String
	 *            new elementName property value
	 * @exception Exception
	 */
	@Override
	public void setElementName(String elementName) {

		this.elementName = elementName;
	} // setElementName

} // Class SettingData
