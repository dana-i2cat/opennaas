<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
	<title>Converting CIM MOF files to Java files</title>
</head>

<body>
	<h1>Converting CIM MOF files to Java files</h1>

	<ul>
		<li><a href="#intro">Introduction</a></li>
		<li><a href="#issues">Translation issues</a></li>
		<li><a href="#maven">Building and running the translator</a></li>
		<li><a href="#errors">Errors and Testing the translator</a></li>
		<li><a href="#todos">To-dos</a></li>
	</ul>


	<h2><a name="brief">Brief description of translatecim</a></h2>

	<p>
		The Common Information Model (CIM) is a data representation defined by
		the <a href="http://www.dmtf.org/">Distributed Management Task Force</a>
		(DMTF).
		The model is defined by a set of MOF files distributed by the DMTF.
		MOF is a language also defined by the DMTF.
		TranslateCIM is a program that translates the MOF files into Java source files.
		TranslateCIM is written using ANTLR, a parser generator system.
		TranslateCIM was written to allow the author to write
		a network management application that is compatible with the CIM
		standard.
	</p>

	<p>
		CIM defines about 1200 standard objects for use in applications.  Trouble is, it's
		"language agnostic", meaning the objects aren't defined in a real language.  CIM is
		specified in MOF (Managed&nbsp;Object&nbsp;Format), a pseudo-language.  There are
		other programs that translate CIM into Java, but they are old, incomplete,
		proprietary, nonportable, or otherwise sucky.  TranslateCIM is free and portable.
		It parses the latest version of CIM as of December 2008.  It produces legal
		Java output, though work remains to be done to make the output files reflect
		all the details of CIM.  TranslateCIM uses ANTLR&nbsp;3, a modern parser generator
		system, so it would be possible to write additional back ends to produce
		languages other than Java.
	</p>	


	<h2><a name="intro">Introduction</a></h2>

	<p>
		The Distributed&nbsp;Management&nbsp;Task&nbsp;Force (DMTF) describes the
		Common&nbsp;Information&nbsp;Model (CIM) in the 
		<a href="../DSP0004_2.4.0.pdf">CIM&nbsp;Infrastructure&nbsp;Specification</a>.
		The specification describes CIM concepts and a language called
		Managed&nbsp;Object&nbsp;Format (MOF), which is *not* the
		Meta&nbsp;Object&nbsp;Facility defined by the OMG.
		MOF is used to define the classes in the CIM.
		There is one MOF file for each class in the CIM.
		There about 1200 MOF files organized in a directory tree.
		This web page describes a program named TranslateCIM that translates CIM MOF
		files into corresponding Java files suitable for use in applications.
	</p>

	<p>
		In the CIM MOF distribution directory, a special master MOF file contains
		"include" statements that include all the other files.
		The master file starts
		by including 2 files that define qualifiers used in all the other files.
		The
		remaining include statements include the rest of the MOF files, each of which
		defines a single CIM class.
		The include statements are in order such that
		superclasses are defined before subclasses, as specified in the 
		<a href="../DSP0004_2.4.0.pdf">CIM&nbsp;Infrastructure&nbsp;Specification</a>,
		section "4.5.2&nbsp;Subclasses", lines 956-957.
	</p>

	<p>
		Once the output files have been created, they must be compiled in the
		same order that they appear in the include file, to insure that classes
		are defined before they are referenced.
		To make this easy, the translator program outputs a shell script
		that contains "javac" commands that compile the files in the proper order.
	</p>

	<p>
		The translator program is generated by ANTLR, a translator generator system
		designed for jobs like this.
		The stuff that I used to learn ANTLR is in
		~/antrlplay, including Pedro&nbsp;Assis's grammar for ANTLR&nbsp;2.  My
		grammar for ANTLR&nbsp;3 is in ~/TranslateCIM.
	</p>

	<p>
		The translator opens the master MOF file and processes all the include statements.
		Whenever it encounters the end of a class definition, it writes a Java file.
		The translator creates an output directory tree that follows the layout of the
		input directory tree.
		In general, the output directory contains a Java file for every MOF file in
		the input directory.
	</p>

	<p>
		The translator reads the entire
		set of CIM files and writes the entire set of Java files.
		It does this instead of processing one file at a time because

		<ul>
			<li>
				We need an output script to compile things in the proper order,
				hence I have to read the master MOF file anyway.
			</li>
			<li>
				MOF qualifiers have to be defined (included) before any class
				file is translated.
				This is done by the master MOF file.
				If I made a translator that could translate MOF files one at a
				time, I'd have to artificially include the qualifier files in some
				klunky way.
			</li>
			<li>
				I can rely on the fact that superclasses have been defined
				before subclasses.
				This isn't needed for parsing, but it's extra structure.
			</li>
			<li>
				Execution speed isn't an issue.
				ANTLR makes fast code.
				It can translate all 1200 input files in seconds.
			</li>
			<li>
				It's the way the MOF files were meant to be processed.
				</li>
		</ul>
	</p>

	<p>
		ANTLR generates translators that have 2 phases of translation:
		lexical analysis phase followed by a parsing phase.
		The translator reads all ~1200 CIM MOF files and lexically
		analyzes them to produce a single stream of tokens in memory.
		When that's done, it starts the parsing phase, which reads the
		token stream and writes one output file whenever it encounters the
		end of a class definition.
		The translator uses ANTLR stringTemplates to create the actual
		output, which should make it relatively easy to make the
		translator produce some other output language than Java if desired.
	</p>

	<p>
		ANTLR uses recursive-descent parsing, which allows the process to
		be broken into pieces naturally.
		The "output" of each rule is passed up to the enclosing
		rule so that the processing at each level can be modular.
		Each parser rule may return value(s) that represent the rule.
		The returned values are often in the form of a stringTemplate or
		"st", but can be any Java type.
		For example, the list of qualifiers for a class is best represented
		as a Java HashMap, with the name of the qualifier as the key.
	</p>


	<h2><a name="issues">Translation issues</a></h2>


	<h3>NULL</h3>

	<p>
		The 
		<a href="../DSP0004_2.4.0.pdf">CIM&nbsp;Infrastructure&nbsp;Specification</a>
		says, in section 4.11.6,

		<blockquote><em>
			All types can be initialized to the predefined constant NULL, which indicates
			that no value is provided.
			The details of the internal implementation of the NULL value are not mandated
			by this document.
		</em></blockquote>		
	</p>

	<p>
		This almost doesn't matter, since the CIM MOF files don't actually use the
		keyword "NULL" except in comments.
		There is one kinda/sorta exception: in
		Device/CIM_SpareConfigurationCapabilities.mof, a uint32 is initialized to
		"null".
		This seems to be a typo - the word should probably be capitalized.
		ANyway, the obvious way to support "NULL" in Java is via Java's "null" keyword.
		That works fine for Java objects but not for primitive types.
		Furthermore, the comment next to the usage indicates a clear difference
		between "NULL" and a zero value.
		To handle it, I put a special case in the parser that treats
		"null" as "NULL".
		The proper "fix" is to change TranslateCIM so that it doesn't generate
		code that uses Java primitives.
		Until I do that, the Java produced by TranslateCIM won't be
		compatible with the CIM specification.  Sigh.
	</p>


	<h3>Unimplemented MOF constructs</h3>

	<p>
		The
		<a href="../DSP0004_2.4.0.pdf">CIM&nbsp;Infrastructure&nbsp;Specification</a>
		defines MOF, a language used to define CIM classes.
		MOF is defined very specifically in the specification.
		There's even a Backus-Naur grammar in Appendix&nbsp;A.
		Some parts of the MOF language are not actually used in any of
		the MOF files that define CIM classes.
		They are omitted from the translator.
		The omitted parts include:

		<ul>
			<li>
				assocDeclaration
			</li>
			<li>
				indicDeclaration
			</li>
			<li>
				instanceDeclaration
			</li>
			<li>
				Pragmas other than "include" or "locale"
			</li>
			<li>
				The specification documents escape sequences that are allowed
				in string literals.  Only \", \' and \n are used in the CIM MOF
				files.  Other escape sequences are defined in the specification,
				but are not actually used in the MOF files.
				The translator doesn't recognize them.
				They are \b, \t, \f, \r, \\, \x and \X.
			</li>
		</ul>

		The ANTLR grammar that defines the translator was adapted from the Backus-Naur
		grammar in the CIM&nbsp;Specification.
		Pedro&nbsp;Assis made the initial
		changes to turn it into a grammar that could be accepted by ANTLR version 2.
		I made further changes to turn it into an ANTLR v3 grammar, and then I refined
		it further to make it parse the actual CIM files and produce output files.
	</p>


	<h3>CIM field names (property names) violate Java naming conventions</h3>

	Java naming conventions specify that field names (variables) should start
	with a lowercase letter.
	In CIM, these are called "properties", and they start with a capital letter.
	The translator converts CIM properties into Java fields.
	I could either force the first character to lowercase, or
	just let them violate the Java convention.
	Dunno what to do yet.
	For now, I use the CIM names, violating Java convention.


	<h3>Deprecated things: to omit or not to omit?</h3>

	<p>
		Should the translator emit classes, fields and methods marked "Deprecated"? 
		It's nice not to have them cluttering up libraries, but omitting them may not
		be right in some situations.
		By default, the translator emits deprecated things, but a command-line
		command-line named "nodeprecated" (name inspired
		by javadoc options) causes them to be skipped.
	</p>

	<p>
		Unfortunately, there are some mistake in the CIM MOF files.
		Some deprecated classes are extended by non-deprecated classes.
		When you run translateCIM with the "-nodeprecated" option, these classes
		will cause
		"class&nbsp;xxx&nbsp;not&nbsp;defined" errors and/or the resulting Java won't
		compile.
		There are some mealy-mouthed comments about this in the CIM MOF files,
		saying it'll be fixed when there's a "major&nbsp;Schema&nbsp;release".
		If you really want to produce Java that doesn't have deprecated stuff,
		you'll have to manually remove the "Deprecated" qualifier from the class
		definition in the following files in CIM&nbsp;2.20.1:
		<ul>
			<li>Core/CIM_FRU.mof</li>
			<li>Network/CIM_IPRoute.mof</li>
			<li>Network/CIM_CIM_NextHopRouting.mof</li>
			<li>Network/CIM_NetworkService.mof</li>
			<li>System/CIM_DiagnosticSetting.mof</li>
			<li>System/CIM_DiagnosticResult.mof</li>
			<li>Core/CIM_ProvidesServiceToElement.mof</li>
			<li>Device/CIM_StorageLibrary.mof</li>
			<li>User/CIM_PublicKeyCertificate.mof</li>
		</ul>
	</p>

	<p>
		Of course, the above list is likely to change with every release of CIM.
	</p>


	<h3>Experimental things: to omit or not to omit?</h3>

	<p>
		Should the translator emit classes marked "Experimental"?
		By default, the translator emits them, but a command-line command-line
		named "omitExperimental" will cause them to be skipped.
	</p>


	<h3>Enums: to emit or not?</h3>

	<p>
		CIM defines many enumerations, many of which can be represented as
		enums in Java.
		Java enums provide type safety at compile-time.
		By default, the translator will convert CIM data properties into Java
		enums when it can.
		A command-line option named "noenums" (name inspired by javadoc options)
		turns this behavior off and causes the translator
		to produce older-style, less type-safe "typesafe&nbsp;enums".
	</p>


	<h3>Dangerous backslashes in cimv215.mof</h3>

	<p>
		In CIM version 2.15, the master MOF file contained include statements
		with file names that had Microsoft-Windows-style backslashes to delimit
		directories.
		MOF syntax uses backslashes to introduce escape sequences, so this
		wasn't legal MOF.
		It happens that the "backslash&nbsp;sequences" in the file didn't
		happen to match any of the escape sequences used in	MOF string literals.
		A parser would be justified if it were to emit
		"unrecognized escape sequence" errors.
		Instead, just to make it work,
		I put a "NonEscapeSequence" token into the grammar to explicitly allow
		"\C" and "\P" as special escape sequences.
		All the file names in the file happen to start with "C" or "P", so this
		fixes the problem.
		What a hack.
	</p>


	<h3>Names of Values in properties</h3>

	<h4>Duplicates</h4>

	<p>
		Some CIM properties have Values that have names that are duplicates.
		For example, in Device/CIM_AssociatedCacheMemory.mof, the
		"ReplacementPolicy" property has a Values qualifier with the word
		"Unknown" defined twice.
		Device/CIM_DiskPartition.java has many duplicate occurrences of
		"Microsoft".
		Values strings must be unique, whether enums are generated or not,
		so TranslateCIM appends a digit to each name to make it unique,
		producing "Microsoft", "Microsoft1", "Microsoft2", etc.
	</p>


	<h4>Reserved words</h4>

	In cimv218Experimental-MOFs/Core/CIM_BaseMetricDefinition.mof,
	the "DataType" property has Values named "boolean" and "datetime".
	If we're generating enums, we can't use those names.
	TranslateCIM does &lt;TBD&gt; to fix the problem.


	<h2><a name="maven">Building and running the translator</a></h2>


	<h3><a name="quick">Quick reminder of how to do it</a></h3>

	<blockquote><code><strong>
		jrm<br>
		mvn clean<br>
		mkdir -p /tmp/org/dmtf/cim<br>
		mp<br>
		rp<br>
		jp<br>
		jd<br>
	</strong></code></blockquote>



	<h3><a name="slow">More details</a></h3>

	<p>
		To use maven to convert the grammar into a translator:

		<blockquote><code><strong>
			cd ~/TranslateCIM<br>
			mvn package
		</strong></code></blockquote>
	</p>

	<p>
		To run the translator, see the "rp" function in my .bashrc file.  This
		is the hack way to run the translator.  The right way is via maven, as
		described in the next section.
	</p>

	<p>
		Maven philosophy says that each maven project should produce a single
		artifact: a jar file or something.  We now produce an executable jar
		file containing the translate-cim program.  For the Kyben project,
		we need another jar file containing the CIM objects.
		That's a different jar file, so	I'll need another Maven project to
		execute the
		translator to convert CIM files into Java files, then compile the
		Java files into class files, then package them into a jar file.  Oh,
		yeah, and produce javadoc.  If I ever get around to writing Kyben,
		I'll need yet a third maven project for the Kyben code.
	</p>

	<p>
		I think I need at least the following separate Maven projects:

		<dl>
			<dt>1. translate-cim</dt>
			<dd>
				Runs ANTLR to convert the grammar into Java, compiles the Java,
				runs tests, and packages the program into an executable jar.
			</dd>
			<dt>2. cim-java</dt>
			<dd>
				Depends on translate-cim.
				Runs translate-cim to convert CIM mof files into Java, compiles
				the Java, runs tests, and packages the program into an executable
				jar.  For this project, I have to write a Maven plugin for
				translate-cim.
			</dd>
			<dt>3. kyben</dt>
			<dd>
				Depends on cim-java.
			</dd>
		</dl>
	</p>

	<p>
		The cim-java project needs to run translate-cim, which in the Maven
		world means I have to modify translate-cim to exist within the Maven
		ecosystem.  I'll have to modify translate-cim to turn it into a
		Maven mojo, and then use maven-plugin-plugin to create a Maven
		plugin that runs the mojo.  Then, in the pom.xml file for cim-java,
		I can bind the translate-cim mojo to the lifecycle phase named
		generate-sources.
	</p>

	<p>
		I wrote translate-cim to get its parameters from the command line.
		In the Maven ecosystem, a mojo gets its parameters from pom.xml
		files or from the Maven command line (like when I say "mvn -Dtest=TestOneFile").
		To get parameter values from the Maven ecosystem,  I just need to
		use javadoc annotations in the translate-cim program to tell the
		Maven plugin builder which variables are parameters.  Cool.  I'm sure
		that the same application can then be run from a command line
		or as a Maven plugin.  Now it's just a matter of filling in the
		details :-).
	</p>


	<h2><a name="errors">Errors and Testing the translator</a></h2>

	<p>
		How should I test that TranslateCIM is "correct"?  Perhaps it
		is correct if

		<ul>
			<li>
				It reads all the CIM files without error.
			</li>
			<li>
				It produces a Java file for every CIM file.
			</li>
			<li>
				The Java files compile without error.
			</li>
			<li>
				The Java files faithfully implement every enumeration
				in the CIM files.
			</li>
			<li>
				The Java files implement every qualifier in the
				CIM files.
			</li>
			<li>
				There is a test for every error that my Java
				code can produce, like <nobr>"include file not found"</nobr>
				and <nobr>"class undefined"</nobr>.
			</li>
		</ul>
	</p>

	<p>
		The above tests aren't really "unit" tests.
		To implement the above I don't make use of ANTLR's unit testing
		framework named "gunit", because gunit is designed to test individual
		grammar rules.
		I have implemented jUnit tests that test each of the errors in
		my Java code can produce.
	</p>

	<p>
		The recommended way to report an error in ANTLR is to 
		throw an ANTLR RecognitionException and let ANTLR report the
		problem and try to recover.  This approach makes a translator
		that "keeps on truckin'" - it doesn't die on the first error
		it encounters.  That's fine for compilers, but I'm parsing a
		relatively fixed set of input files, so TranslateCIM either
		works or it doesn't.  I don't need to keep on truckin.  The
		ANTLR book describes how to change a translator to make it quit
		on the first error, but I had trouble making it work.  I couldn't
		figure out how to make the lexer phase die on with a
		"can't find include file" error.
	</p>

	<p>
		Instead of throwing a RecognitionException and letting ANTLR try
		to recover, I throw my own unchecked exceptions, defined in file
		TranslateCIMExceptions.  I couldn't throw checked exceptions
		because there isn't any way to make ANTLR generate the "throws"
		clauses that would be needed in the methods NATLR generates.
	</p>

	<p>
		Also, I don't want the user to see a big ugly stack dump whenever
		there's an error, so I catch my exceptions in the main function
		and output only the one-line error message in the exception.
	</p>
	
	<p>
		Use "mvn&nbsp;test" to run tests.
		This compiles and executes the test programs stored in
		~/TranslateCIM/src/test/java/com/kyben/translatecim.
		Following maven conventions, the programs read test
		data files stored in
		~/TranslateCIM/src/test/resources.
		Maven automatically adds that directory to the classpath, so
		that test programs can access the files by calling
		getResourceByStream.
		This convention allows maven to avoid referring to files by
		explicit file paths.
		To use this convention yet still allow TranslateCIM to accept
		explicit file paths on the command line, the test programs
		execute TranslateCIM slightly differently than stand-alone
		TranslateCIM executes.
		Stand-alone TranslateCIM parses explicit file names from the
		cammand line.
		Test cases use getResourceAsStream, then extract the file
		names, and feed those to TranslateCIM.
		Odd, but this approach allows me to have test cases in the
		maven-style development tree in the maven-standard place,
		yet still have a real program that accepts file names on
		the command line.		
	</p>



	<h2><a name="todos">To-dos</a></h2>


	<h3>Map CIM types to Java types</h3>

	<p>
		I map CIM datatypes into Java datatypes as shown by the templates
		at the bottom of the TranslateCIM.stg file.  It's not possible to
		map things perfectly.  Here are some of the problems and issues:
	</p>

	<ul>
		<li>
			Java doesn't have unsigned ints, so I map CIM's unsigned ints
			into Java signed types.  Problems include
			<ul>
				<li>
					In Support/PRS_Transaction.mof, the property named
					TransactionType is a uint8, but it's documented as
					being able to be set to 255.  If you run TranslateCIM
					with "-noenum", you'll get a PRS_Transaction.java file
					that tries to initialize the property to 255, which
					the Java compiler won't allow for a "byte".
				</li>
				<li>
					In Network/CIM_AutonomousSystem.mof, the property named
					ASnumber is a uint16 that will certainly take on values
					like 65502.
				</li>
				<li>
					In Application/CIM_BIOSElement.mof, the property named
					LoadedStartingAddress is a uint64 that is a 64-bit
					address.  It might be given a value that has the top
					bit set and be considered "signed" by Java.
				</li>
			</ul>
			TranslateCIM doesn't solve this - it dodges it.  It uses the
			next larger signed size to hold CIMs unsigned values - a CIM
			"uint8" maps to a 16-bit signed "short".  There's no good Java
			thing to map a CIM uint64 to, so I map it to a signed long and
			pray.  This issue will probably have to be revisited later.
		</li>
		<li>CIM's datetime are mapped into a Java String.  Should it be a Java Date or something?</li>
		<li>CIM's string data types without a MaxLen are mapped to a Java String.</li>
		<li>CIM's string data types that have a MaxLen are mapped to a Java StringBuffer.</li>
		<li>Enums<br>
			<p>
				The translator emits enums by default.  CIM data properties often have
				values that aren't a strict sequence starting with 0, so the translator
				can't just use Java's default ordinal values for enums.  Instead, it
				generates "instance&nbsp;fields" as described in Joshua&nbsp;Bloch's
				<em>Effective&nbsp;Java</em>, second edition, page 158.
			</p>			
			<ul>
				<li>
					CIM properties can be mapped to Java enums if the following conditions
					are true:
					<ol>
						<li>
							The command line doesn't contain "-noenums".
						</li>
						<li>
							It contains no ranges, except for ranges with names like,
							"xxx&nbsp;Reserved", which the translator ignores (it outputs
							a comment for these ranges).
						</li>
						<li>
							The data type is uint8, sint8, uint16, sint16, uint32, or sint32.
						</li>
						<li>
							All the elements of the ValueMaps are integers
						</li>
					</ol>
					If any of these conditions fail, TranslateCIM generates an older-style
					"typesafe&nbsp;enum".  Examples of real CIM types that might be Java
					enums include:
					<ul>
						<li>uint8 - StandardMonth in
							~/cim/cimv218Experimental-MOFs/Core/CIM_TimeZoneSettingData.mof
						</li>
						<li>uint16 - common</li>
						<li>uint32 ~/cim/cimv218Experimental-MOFs/Network/CIM_BGPPathAttributes.mof
						</li>
					</ul>
					Examples that can't be translated to Java enum:
					<ul>
						<li>Negative numbers: sint8 - StandardDayOfWeek in
							~/cim/cimv218Experimental-MOFs/Core/CIM_TimeZoneSettingData.mof.  Looks
							stupid, but it's the CIM standard.
						</li>
						<li>strings - MatchFieldName in
							~/cim/cimv218Experimental-MOFs/Network/CIM_X509CredentialFilterEntry.mof.
							Can't convert it.
						</li>
						<li>
							If the ValueMap defines ranges other than at the end of the sequence,
							like the one for RequestStateChange in
							~/cim/cimv218Experimental-MOFs/Core/CIM_EnabledLogicalElement.mof.
						</li>
						<li>
							If the Values contains duplicates, like "Microsoft" in the
							PartitionSubtype property in
							~/cim/cimv218Experimental-MOFs/Device/CIM_DiskPartition.mof and "Undefined" in the
							ErrorInfo property in ~/cim/cimv218Experimental-MOFs/Device/CIM_Memory.mof
						</li>
					</ul>
				</li>
				<li>
					Enum names:<br>
					The CIM Value named "boolean" is a Java reserved word.  Should I make a
					general rule that all enum constants start with 'e' or something?  I 
					currently put 't' in front of Values that start with a digit.  I also
					convert all kinds of special characters into underscores just to get
					the Java to compile.  It's ugly, and could be made at least a little better.
				</li>
			</ul>
		</li>
	</ul>

	<h3>Generate good javadoc</h3>

	<p>
		Just for reference, and to show what TranslateCIM should aim to beat, the DMTF's CIM Javadoc is at
		<a href="/nets/intro/staff/siemsen/tmp/cim_schema_2">/nets/intro/staff/siemsen/tmp/cim_schema_2/</a>.
		To install it there, I followed the direction in the README file under
		"Get&nbsp;the&nbsp;CIM&nbsp;documentation".
	</p>

	<p>
		The javadoc created by running the "javadoc" tool on the TranslateCIM output files is at
		<a href="/nets/intro/staff/siemsen/internal/projects/kyben/TranslateCIM/javadoc/">http://localhost/nets/intro/staff/siemsen/internal/projects/kyben/TranslateCIM/javadoc/</a>
	</p>

	<p>
		For information about the options to the "javadoc" tool, see
		<a href="http://127.0.0.1/java/docs/technotes/tools/solaris/javadoc.html">http://127.0.0.1/java/docs/technotes/tools/solaris/javadoc.html</a>
	</p>

	<ul>
		<li>
			I generate "@Deprecated" correctly, but the argument that says what
			the new class is needs to be a link to the new class.
			Also, need to handle multiple strings in "deprecated" comments, see
			Core/CIM_Configuration.mof.
		</li>
		<li>
			When writing javadoc comments, remember that javadoc thinks all lines that start
			with "@" are javadoc tags,  so I have to check for and explicitly replace any
			"@" signs that happen to end up on the front of a line with &amp;#064;
		</li>
		<li>
			Make all references to known classes be "{@link}" tags.  Downside is that
			@link requires that they change from, like, "ManagedElement" to
			"CIM_ManagedElement".  Yuck!
		</li>
		<li>
			Must convert the "Values" and "ValueMap" qualifiers into a table to tell the user
			what the values can be, whether it's a Java enum or not.  Also, provide an example
			of how to call the setter to set a value.
		</li>
		<li>
			All the qualifiers that are used have to show up in the javadoc in some form or
			another.  For "Abstract", it's done.  For many others, I need to emit a comment.
		</li>
		<li>
			Create the package-info.java files.  I created one for the top-level package
			and I copy it to the right place as part of the "rp" command.  This isn't a
			great way to do it.  Besides, I need a package-info.java for each of the
			subpackages (Common&nbsp;Models) of CIM.  The Common&nbsp;Models are described in
			<a href="http://www.wbemsolutions.com/tutorials/DMTF/cim-common.html">http://www.wbemsolutions.com/tutorials/DMTF/cim-common.html</a>,
			which has some good information about the Network common model.
		</li>
		<li>
			Do spelling and other fixups.  Like "one-&nbsp;liner" in CIM_ManagedElement.
			Or words that appear twice like "the&nbsp;the".
		</li>
		<li>
			Use @code for the example of how to call a setter to set the value of a property.
		</li>
		<li>
			Can I use @return?
		</li>
	</ul>


	<h3>Other to-dos</h3>

	<ul>
		<li>
			Perhaps the omitExperimental option should be removed.  "Experimental"
			qualifiers appear only in the files in the "Experimental" tree.  That
			tree contains all the new stuff as well as copies of the files in
			the "Final" tree.
		</li>
		<li>
			It generates a build file that's system-dependent.  Dunno how to fix this.
		</li>
		<li>
			Now, 'org.dmtf.cim' is hard-coded into the .stg file and the command line that
			runs the parser, and the command lines in the generated script that compiles
			the code.  Must be a better way.  Also, consider generating the directory structure.
		</li>
		<li>
			Generate annotations.  See
			<a href="http://jcp.org/aboutJava/communityprocess/final/jsr250/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr250/index.html</a>

			Here are the ones I generate:

			<ul>
				<li>@Deprecated</li>
				<li>@Generated<br>
					I generate this, but it requires importing javax.annotation, which isn't available, perhaps
					it's a Java 6 thing?  Anyway, for now I commented it out of the TranslateCIM-java.stg file.
				</li>
			</ul>

			to consider:

			<ul>
				<li>@Override</li>
			</ul>
		</li>
		<li>
			Should I generate constructors?  See the "REQUIRED" qualifier.
		</li>
		<li>
			Should I generate getters and setters?
		</li>
		<li>make maven run the translator as a "test"</li>
		<li>see the TODO section in the grammar</li>
		<li>qualifiers
			<ul>
				<li>Aggregate - it's "association", dunno what to do with it</li>
				<li>ArrayType - Says whether the array is "Bag", "Ordered" or "Indexed".  These
					don't map directly to Java containers, so I'd have to come up with some
					new container classes.  Maybe someday :-)
				</li>
				<li>BitMap, BitValues - never used!</li>
				<li>Composition - it's "association", dunno what to do with it</li>
				<li>Counter - dunno</li>
				<li>Deprecated - done</li>
				<li>Description - done</li>
				<li>DisplayName - never used!</li>
				<li>DN - never used!</li>
				<li>EmbeddedInstance - dunno</li>
				<li>EmbeddedObject - never used!</li>
				<li>Exception - never used!</li>
				<li>Experimental - dunno - note that all the Experimental stuff is in it's
					own subdirectory separate from the Final stuff, so the "omitExperimental"
					command-line option is misguided.
				</li>
				<li>Gauge - dunno</li>
				<li>In - perhaps there's a Java annotation for this? See "Out".</li>
				<li>Key - dunno - note that it's immutable, set only at creation time</li>
				<li>MappingStrings - dunno</li>
				<li>Max - dunno</li>
				<li>MaxLen - I should create a StringBuffer instead of a String, and I
					should extend this to arrays of strings.  How can I enforce the maximum
					length?  Perhaps create my own new class, a wrapper around StringBuffer
					that enforces the length?
				</li>
				<li>MaxValue - dunno</li>
				<li>Min - dunno</li>
				<li>MinLen - dunno, means create a StringBuffer instead of a String?</li>
				<li>MinValue - dunno</li>
				<li>ModelCorrespondence - dunno</li>
				<li>NullValue - never used!</li>
				<li>Ocl - never used!</li>
				<li>OctetString - dunno</li>
				<li>Out - perhaps there's a Java annotation for this? See "In".</li>
				<li>OverRide - perhaps generate an "override" annotation?  see <a href="http://java.sun.com/docs/books/tutorial/java/javaOO/annotations.html">http://java.sun.com/docs/books/tutorial/java/javaOO/annotations.html</a></li>
				<li>Propagated - dunno</li>
				<li>Read - dunno (is this ever used?)</li>
				<li>Required - make it so that you can't instantiate this class without
					providing a value for this property.  I think this may imply that I should
					generate constructors for all classes.
				</li>
				<li>Schema - dunno (is this ever used?)</li>
				<li>Source - never used!</li>
				<li>SourceType - never used!</li>
				<li>Static - I should probably map this to Java "static"</li>
				<li>Terminal - never used!</li>
				<li>Units - I could turn this into an enum</li>
				<li>ValueMap - I don't handle these yet</li>
				<li>Values - I make enums out of them, but what if noenums is true?</li>
				<li>Version - emit it as a comment</li>
				<li>Weak - dunno</li>
				<li>Write - dunno</li>
			</ul>
		</li>
	</ul>

</body>
</html>
