/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Wed Jan 12
 * 09:21:06 CET 2011.
 */

package org.opennaas.extensions.router.model;

import java.io.*;
import java.lang.Exception;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class ResourcePool as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the ResourcePoolBean Interface. The CIM class ResourcePool is described as follows:
 * 
 * A ResourcePool is a logical entity (with associated controls)provided by the host system for the purpose of allocation and assignment of resources.
 * A given ResourcePool may be used to allocate resources of a specific type. Hierarchies of ResourcePools may be created to provide administrative
 * control over allocations. In the cases where resources are subdivided, multiple resource pools may exist (e.g. nodal boundaries in NUMA-like
 * systems). In systems that support over commitment, pools represent the reservable capacity, not an upper bound or limit on the maximum amount that
 * can be allocated. Admission control during power on may detect and prevent systems from powering due to resource exhaustion. For example, over
 * commitment on a ResourcePool with ResourceType=Memory would require that sufficient space be available in some backing-store, that may be managed
 * through a storage ResourcePool.
 */
public class ResourcePool extends LogicalElement implements Serializable {

	/**
	 * This constructor creates a ResourcePoolBeanImpl Class which implements the ResourcePoolBean Interface, and encapsulates the CIM class
	 * ResourcePool in a Java Bean. The CIM class ResourcePool is described as follows:
	 * 
	 * A ResourcePool is a logical entity (with associated controls)provided by the host system for the purpose of allocation and assignment of
	 * resources. A given ResourcePool may be used to allocate resources of a specific type. Hierarchies of ResourcePools may be created to provide
	 * administrative control over allocations. In the cases where resources are subdivided, multiple resource pools may exist (e.g. nodal boundaries
	 * in NUMA-like systems). In systems that support over commitment, pools represent the reservable capacity, not an upper bound or limit on the
	 * maximum amount that can be allocated. Admission control during power on may detect and prevent systems from powering due to resource
	 * exhaustion. For example, over commitment on a ResourcePool with ResourceType=Memory would require that sufficient space be available in some
	 * backing-store, that may be managed through a storage ResourcePool.
	 */
	public ResourcePool() {
	};

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property instanceID.
	 */
	private String	instanceID;

	/**
	 * This method returns the ResourcePool.instanceID property value. This property is described as follows:
	 * 
	 * Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. To ensure uniqueness
	 * within the NameSpace, the value of InstanceID should be constructed using the following "preferred" algorithm: <OrgID>:<LocalID> Where <OrgID>
	 * and <LocalID> are separated by a colon (:), and where <OrgID> must include a copyrighted, trademarked, or otherwise unique name that is owned
	 * by the business entity that is creating or defining the InstanceID or that is a registered ID assigned to the business entity by a recognized
	 * global authority. (This requirement is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure
	 * uniqueness, <OrgID> must not contain a colon (:). When using this algorithm, the first colon to appear in InstanceID must appear between
	 * <OrgID> and <LocalID>. <LocalID> is chosen by the business entity and should not be reused to identify different underlying (real-world)
	 * elements. If the above "preferred" algorithm is not used, the defining entity must ensure that the resulting InstanceID is not reused across
	 * any InstanceIDs produced by this or other providers for the NameSpace of this instance. For DMTF-defined instances, the "preferred" algorithm
	 * must be used with the <OrgID> set to CIM.
	 * 
	 * @return String current instanceID property value
	 * @exception Exception
	 */
	@Override
	public String getInstanceID() {

		return this.instanceID;
	} // getInstanceID

	/**
	 * This method sets the ResourcePool.instanceID property value. This property is described as follows:
	 * 
	 * Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. To ensure uniqueness
	 * within the NameSpace, the value of InstanceID should be constructed using the following "preferred" algorithm: <OrgID>:<LocalID> Where <OrgID>
	 * and <LocalID> are separated by a colon (:), and where <OrgID> must include a copyrighted, trademarked, or otherwise unique name that is owned
	 * by the business entity that is creating or defining the InstanceID or that is a registered ID assigned to the business entity by a recognized
	 * global authority. (This requirement is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure
	 * uniqueness, <OrgID> must not contain a colon (:). When using this algorithm, the first colon to appear in InstanceID must appear between
	 * <OrgID> and <LocalID>. <LocalID> is chosen by the business entity and should not be reused to identify different underlying (real-world)
	 * elements. If the above "preferred" algorithm is not used, the defining entity must ensure that the resulting InstanceID is not reused across
	 * any InstanceIDs produced by this or other providers for the NameSpace of this instance. For DMTF-defined instances, the "preferred" algorithm
	 * must be used with the <OrgID> set to CIM.
	 * 
	 * @param String
	 *            new instanceID property value
	 * @exception Exception
	 */
	@Override
	public void setInstanceID(String instanceID) {

		this.instanceID = instanceID;
	} // setInstanceID

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property poolID.
	 */
	private String	poolID;

	/**
	 * This method returns the ResourcePool.poolID property value. This property is described as follows:
	 * 
	 * An opaque identifier for the pool. This property is used to provide correlation across save and restore of configuration data to underlying
	 * persistent storage.
	 * 
	 * @return String current poolID property value
	 * @exception Exception
	 */
	public String getPoolID() {

		return this.poolID;
	} // getPoolID

	/**
	 * This method sets the ResourcePool.poolID property value. This property is described as follows:
	 * 
	 * An opaque identifier for the pool. This property is used to provide correlation across save and restore of configuration data to underlying
	 * persistent storage.
	 * 
	 * @param String
	 *            new poolID property value
	 * @exception Exception
	 */
	public void setPoolID(String poolID) {

		this.poolID = poolID;
	} // setPoolID

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property primordial.
	 */
	private boolean	primordial;

	/**
	 * This method returns the ResourcePool.primordial property value. This property is described as follows:
	 * 
	 * If true, "Primordial" indicates that this ResourcePool is a base from which resources are drawn and returned in the activity of resource
	 * management. Being primordial means that this ResourcePool shall not be created or deleted by consumers of this model. However, other actions,
	 * modeled or not, may affect the characteristics or size of primordial ResourcePools. If false, "Primordial" indicates that the ResourcePool, a
	 * concrete Resource Pool, is subject to resource allocation services functions. This distinction is important because higher-level ResourcePools
	 * may be assembled using the Component or ElementAllocatedFromPool associations. Although the higher-level abstractions can be created and
	 * deleted, the most basic, (i.e. primordial), hardware-based ResourcePools cannot. They are physically realized as part of the System, or are
	 * actually managed by some other System and imported as if they were physically realized.
	 * 
	 * @return boolean current primordial property value
	 * @exception Exception
	 */
	public boolean isPrimordial() {

		return this.primordial;
	} // getPrimordial

	/**
	 * This method sets the ResourcePool.primordial property value. This property is described as follows:
	 * 
	 * If true, "Primordial" indicates that this ResourcePool is a base from which resources are drawn and returned in the activity of resource
	 * management. Being primordial means that this ResourcePool shall not be created or deleted by consumers of this model. However, other actions,
	 * modeled or not, may affect the characteristics or size of primordial ResourcePools. If false, "Primordial" indicates that the ResourcePool, a
	 * concrete Resource Pool, is subject to resource allocation services functions. This distinction is important because higher-level ResourcePools
	 * may be assembled using the Component or ElementAllocatedFromPool associations. Although the higher-level abstractions can be created and
	 * deleted, the most basic, (i.e. primordial), hardware-based ResourcePools cannot. They are physically realized as part of the System, or are
	 * actually managed by some other System and imported as if they were physically realized.
	 * 
	 * @param boolean new primordial property value
	 * @exception Exception
	 */
	public void setPrimordial(boolean primordial) {

		this.primordial = primordial;
	} // setPrimordial

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property capacity.
	 */
	private long	capacity;

	/**
	 * This method returns the ResourcePool.capacity property value. This property is described as follows:
	 * 
	 * This property represents the maximum amount (in units of AllocationUnits) of reservations that the ResourcePool can support.
	 * 
	 * @return long current capacity property value
	 * @exception Exception
	 */
	public long getCapacity() {

		return this.capacity;
	} // getCapacity

	/**
	 * This method sets the ResourcePool.capacity property value. This property is described as follows:
	 * 
	 * This property represents the maximum amount (in units of AllocationUnits) of reservations that the ResourcePool can support.
	 * 
	 * @param long new capacity property value
	 * @exception Exception
	 */
	public void setCapacity(long capacity) {

		this.capacity = capacity;
	} // setCapacity

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property reserved.
	 */
	private long	reserved;

	/**
	 * This method returns the ResourcePool.reserved property value. This property is described as follows:
	 * 
	 * This property represents the current reservations (in units of AllocationUnits) spread across all active allocations from this pool. In a
	 * hierarchical configuration, this represents the sum of all descendant ResourcePool current reservations.
	 * 
	 * @return long current reserved property value
	 * @exception Exception
	 */
	public long getReserved() {

		return this.reserved;
	} // getReserved

	/**
	 * This method sets the ResourcePool.reserved property value. This property is described as follows:
	 * 
	 * This property represents the current reservations (in units of AllocationUnits) spread across all active allocations from this pool. In a
	 * hierarchical configuration, this represents the sum of all descendant ResourcePool current reservations.
	 * 
	 * @param long new reserved property value
	 * @exception Exception
	 */
	public void setReserved(long reserved) {

		this.reserved = reserved;
	} // setReserved

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property ResourceType.
	 */

	public enum ResourceType {
		OTHER,
		COMPUTER_SYSTEM,
		PROCESSOR,
		MEMORY,
		IDE_CONTROLLER,
		PARALLEL_SCSI_HBA,
		FC_HBA,
		ISCSI_HBA,
		IB_HCA,
		ETHERNET_ADAPTER,
		OTHER_NETWORK_ADAPTER,
		I_O_SLOT,
		I_O_DEVICE,
		FLOPPY_DRIVE,
		CD_DRIVE,
		DVD_DRIVE,
		DISK_DRIVE,
		TAPE_DRIVE,
		STORAGE_EXTENT,
		OTHER_STORAGE_DEVICE,
		SERIAL_PORT,
		PARALLEL_PORT,
		USB_CONTROLLER,
		GRAPHICS_CONTROLLER,
		IEEE_1394_CONTROLLER,
		PARTITIONABLE_UNIT,
		BASE_PARTITIONABLE_UNIT,
		POWER,
		COOLING_CAPACITY,
		ETHERNET_SWITCH_PORT,
		LOGICAL_DISK,
		STORAGE_VOLUME,
		ETHERNET_CONNECTION,
		DMTF_RESERVED,
		VENDOR_RESERVED
	}

	private ResourceType	resourceType;

	/**
	 * This method returns the ResourcePool.resourceType property value. This property is described as follows:
	 * 
	 * The type of resource this ResourcePool may allocate.
	 * 
	 * @return int current resourceType property value
	 * @exception Exception
	 */
	public ResourceType getResourceType() {

		return this.resourceType;
	} // getResourceType

	/**
	 * This method sets the ResourcePool.resourceType property value. This property is described as follows:
	 * 
	 * The type of resource this ResourcePool may allocate.
	 * 
	 * @param int new resourceType property value
	 * @exception Exception
	 */
	public void setResourceType(ResourceType resourceType) {

		this.resourceType = resourceType;
	} // setResourceType

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property otherResourceType.
	 */
	private String	otherResourceType;

	/**
	 * This method returns the ResourcePool.otherResourceType property value. This property is described as follows:
	 * 
	 * A string that describes the resource type when a well defined value is not available and ResourceType is set to 0 for Other.
	 * 
	 * @return String current otherResourceType property value
	 * @exception Exception
	 */
	public String getOtherResourceType() {

		return this.otherResourceType;
	} // getOtherResourceType

	/**
	 * This method sets the ResourcePool.otherResourceType property value. This property is described as follows:
	 * 
	 * A string that describes the resource type when a well defined value is not available and ResourceType is set to 0 for Other.
	 * 
	 * @param String
	 *            new otherResourceType property value
	 * @exception Exception
	 */
	public void setOtherResourceType(String otherResourceType) {

		this.otherResourceType = otherResourceType;
	} // setOtherResourceType

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property resourceSubType.
	 */
	private String	resourceSubType;

	/**
	 * This method returns the ResourcePool.resourceSubType property value. This property is described as follows:
	 * 
	 * A string describing an implementation specific sub-type for this pool. For example, this may be used to distinguish different models of the
	 * same resource type.
	 * 
	 * @return String current resourceSubType property value
	 * @exception Exception
	 */
	public String getResourceSubType() {

		return this.resourceSubType;
	} // getResourceSubType

	/**
	 * This method sets the ResourcePool.resourceSubType property value. This property is described as follows:
	 * 
	 * A string describing an implementation specific sub-type for this pool. For example, this may be used to distinguish different models of the
	 * same resource type.
	 * 
	 * @param String
	 *            new resourceSubType property value
	 * @exception Exception
	 */
	public void setResourceSubType(String resourceSubType) {

		this.resourceSubType = resourceSubType;
	} // setResourceSubType

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property allocationUnits.
	 */
	private String	allocationUnits;

	/**
	 * This method returns the ResourcePool.allocationUnits property value. This property is described as follows:
	 * 
	 * This property specifies the units of allocation used by the Reservation and Limit properties. For example, when ResourceType=Processor,
	 * AllocationUnits may be set to hertz*10^6 or percent. When ResourceType=Memory, AllocationUnits may be set to bytes*10^3. The value of this
	 * property shall be a legal value of the Programmatic Units qualifier as defined in Appendix C.1 of DSP0004 V2.4 or later.
	 * 
	 * @return String current allocationUnits property value
	 * @exception Exception
	 */
	public String getAllocationUnits() {

		return this.allocationUnits;
	} // getAllocationUnits

	/**
	 * This method sets the ResourcePool.allocationUnits property value. This property is described as follows:
	 * 
	 * This property specifies the units of allocation used by the Reservation and Limit properties. For example, when ResourceType=Processor,
	 * AllocationUnits may be set to hertz*10^6 or percent. When ResourceType=Memory, AllocationUnits may be set to bytes*10^3. The value of this
	 * property shall be a legal value of the Programmatic Units qualifier as defined in Appendix C.1 of DSP0004 V2.4 or later.
	 * 
	 * @param String
	 *            new allocationUnits property value
	 * @exception Exception
	 */
	public void setAllocationUnits(String allocationUnits) {

		this.allocationUnits = allocationUnits;
	} // setAllocationUnits

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property consumedResourceUnits.
	 */
	private String	consumedResourceUnits;

	/**
	 * This method returns the ResourcePool.consumedResourceUnits property value. This property is described as follows:
	 * 
	 * This property specifies the units for the MaxConsumable and the Consumed properties.
	 * 
	 * @return String current consumedResourceUnits property value
	 * @exception Exception
	 */
	public String getConsumedResourceUnits() {

		return this.consumedResourceUnits;
	} // getConsumedResourceUnits

	/**
	 * This method sets the ResourcePool.consumedResourceUnits property value. This property is described as follows:
	 * 
	 * This property specifies the units for the MaxConsumable and the Consumed properties.
	 * 
	 * @param String
	 *            new consumedResourceUnits property value
	 * @exception Exception
	 */
	public void setConsumedResourceUnits(String consumedResourceUnits) {

		this.consumedResourceUnits = consumedResourceUnits;
	} // setConsumedResourceUnits

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property currentlyConsumedResource.
	 */
	private long	currentlyConsumedResource;

	/**
	 * This method returns the ResourcePool.currentlyConsumedResource property value. This property is described as follows:
	 * 
	 * This property specifies the amount of resource that the resource pool currently presents to consumers. This property is different from the
	 * Reserved property in that it describes the consumers view of the resource while the Reserved property describes the producers view of the
	 * resource.
	 * 
	 * @return long current currentlyConsumedResource property value
	 * @exception Exception
	 */
	public long getCurrentlyConsumedResource() {

		return this.currentlyConsumedResource;
	} // getCurrentlyConsumedResource

	/**
	 * This method sets the ResourcePool.currentlyConsumedResource property value. This property is described as follows:
	 * 
	 * This property specifies the amount of resource that the resource pool currently presents to consumers. This property is different from the
	 * Reserved property in that it describes the consumers view of the resource while the Reserved property describes the producers view of the
	 * resource.
	 * 
	 * @param long new currentlyConsumedResource property value
	 * @exception Exception
	 */
	public void setCurrentlyConsumedResource(long currentlyConsumedResource)
	{

		this.currentlyConsumedResource = currentlyConsumedResource;
	} // setCurrentlyConsumedResource

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property maxConsumableResource.
	 */
	private long	maxConsumableResource;

	/**
	 * This method returns the ResourcePool.maxConsumableResource property value. This property is described as follows:
	 * 
	 * This property specifies the maximum of amount of consumable resource that the resource pool can present to consumers. This property is
	 * different from the Capacity property in that it describes the consumers view of the resource while the Capacity property describes the
	 * producers view of the resource.
	 * 
	 * @return long current maxConsumableResource property value
	 * @exception Exception
	 */
	public long getMaxConsumableResource() {

		return this.maxConsumableResource;
	} // getMaxConsumableResource

	/**
	 * This method sets the ResourcePool.maxConsumableResource property value. This property is described as follows:
	 * 
	 * This property specifies the maximum of amount of consumable resource that the resource pool can present to consumers. This property is
	 * different from the Capacity property in that it describes the consumers view of the resource while the Capacity property describes the
	 * producers view of the resource.
	 * 
	 * @param long new maxConsumableResource property value
	 * @exception Exception
	 */
	public void setMaxConsumableResource(long maxConsumableResource) {

		this.maxConsumableResource = maxConsumableResource;
	} // setMaxConsumableResource

} // Class ResourcePool
