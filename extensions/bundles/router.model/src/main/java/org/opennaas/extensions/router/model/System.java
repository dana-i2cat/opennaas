/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Wed Jan 12
 * 09:21:06 CET 2011.
 */

package org.opennaas.extensions.router.model;

/*
 * #%L
 * OpenNaaS :: CIM Model
 * %%
 * Copyright (C) 2007 - 2014 Fundació Privada i2CAT, Internet i Innovació a Catalunya
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class System as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the SystemBean Interface. The CIM class System is described as follows:
 * 
 * CIM_System represents an entity made up of component parts (defined by the SystemComponent relationship), that operates as a 'functional whole'.
 * Systems are top-level objects in the CIM hierarchy, requiring no scoping or weak relationships in order to exist and have context. It should be
 * reasonable to uniquely name and manage a System at an enterprise level. For example, a ComputerSystem is a kind of System that can be uniquely
 * named and independently managed in an enterprise. However, these qualities are not true for the power supply (or the power supply sub-'system')
 * within the computer. Although a System can be viewed as a Collection, this view is not the correct model. A Collection is simply a 'bag' that
 * 'holds' its members. A System is a higher-level abstraction, built out of its individual components. It is more than the sum of its parts. Note
 * that System is a subclass of EnabledLogicalElement which allows the entire abstraction to be functionally enabled or disabled at a higher level
 * than enabling or disabling its component parts.
 */
public class System extends EnabledLogicalElement implements Serializable {

	/**
	 * 
	 */
	private static final long	serialVersionUID	= -7882149761777958943L;

	/* HOSTED SERVICES */
	/**
	 * 
	 * @return List of Services associated to this System through HostedService dependency.
	 */
	@SuppressWarnings("unchecked")
	public List<Service> getHostedService() {
		return (List<Service>) this.getToAssociatedElementsByType(HostedService.class);
	}

	/**
	 * Associates hostedService to this System through HostedService dependency.
	 * 
	 * @param hostedService
	 * @return
	 */
	public boolean addHostedService(Service hostedService) {
		if (hostedService == null)
			return false;
		return (HostedService.link(this, hostedService) != null);
	}

	/**
	 * Removes HostedService dependency between hostedService and this System.
	 * 
	 * @param hostedService
	 * @return true if association has been removed. False otherwise (including the association was not present)
	 */
	public boolean removeHostedService(Service hostedService) {
		if (hostedService == null)
			return false;

		Association a = this.getFirstToAssociationByTypeAndElement(HostedService.class, hostedService);
		if (a == null)
			return false;

		a.unlink();
		return true;
	}

	@SuppressWarnings("unchecked")
	public <T extends Service> List<T> getAllHostedServicesByType(T instance) {
		List<Service> list = getHostedService();

		ArrayList<T> desiredServices = new ArrayList<T>();
		for (Service service : list) {
			if (instance.getClass().isInstance(service)) {
				desiredServices.add((T) service);
			}
		}
		return desiredServices;
	}

	public boolean removeAllHostedServicesByType(Class<? extends Service> clazz) {
		List<Service> list = getHostedService();

		boolean somethingIsRemoved = false;
		for (Service service : list) {
			if (clazz.isInstance(service)) {
				removeHostedService(service);
				somethingIsRemoved = true;
			}
		}
		return somethingIsRemoved;
	}

	// HOSTED COLLECTION

	/**
	 * 
	 * @return List of {@link SystemSpecificCollection} associated to this {@link System} through {@link HostedCollection} dependency.
	 */
	@SuppressWarnings("unchecked")
	public List<SystemSpecificCollection> getHostedCollection() {
		return (List<SystemSpecificCollection>) this.getToAssociatedElementsByType(HostedCollection.class);
	}

	@SuppressWarnings("unchecked")
	public <T extends SystemSpecificCollection> List<T> getAllHostedCollectionsByType(Class<T> clazz) {
		List<SystemSpecificCollection> list = getHostedCollection();

		ArrayList<T> desiredServices = new ArrayList<T>();
		for (SystemSpecificCollection hostedCollection : list) {
			if (clazz.isInstance(hostedCollection)) {
				desiredServices.add((T) hostedCollection);
			}
		}
		return desiredServices;
	}

	/**
	 * Adds a {@link HostedCollection} dependency between {@link SystemSpecificCollection} and this {@link System}
	 * 
	 * @param collection
	 * @return
	 */
	public boolean addHostedCollection(SystemSpecificCollection collection) {
		if (collection == null)
			return false;

		return (HostedCollection.link(this, collection) != null);
	}

	/**
	 * Removes {@link HostedCollection} dependency between {@link SystemSpecificCollection} and this {@link System}
	 * 
	 * @param collection
	 * @return true if association has been removed. False otherwise (including the association was not present)
	 */
	public boolean removeHostedCollection(SystemSpecificCollection collection) {
		if (collection == null)
			return false;

		Association a = this.getFirstToAssociationByTypeAndElement(HostedCollection.class, collection);

		if (a == null)
			return false;

		a.unlink();
		return true;

	}

	/**
	 * Removes all {@link HostedCollection} dependencies between {@link SystemSpecificCollection} and this {@link System}
	 * 
	 * @param clazz
	 * @return true if some association has been removed. False otherwise.
	 */
	public boolean removeAllHostedCollectionByType(Class<BridgeDomain> clazz) {
		List<SystemSpecificCollection> list = getHostedCollection();

		boolean somethingIsRemoved = false;
		for (SystemSpecificCollection hc : list) {
			if (clazz.isInstance(hc)) {
				removeHostedCollection(hc);
				somethingIsRemoved = true;
			}
		}
		return somethingIsRemoved;

	}

	/**
	 * Returns the list of {@link HostedCollection} dependencies of a specific type with this {@link System}
	 * 
	 * @param model
	 * @param clazz
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public <T extends SystemSpecificCollection> List<T> getHostedCollectionByType(T clazz) {

		List<SystemSpecificCollection> list = getHostedCollection();
		List<T> listToReturn = new ArrayList<T>();

		for (SystemSpecificCollection hc : list)
			if (clazz.getClass().isInstance(hc))
				listToReturn.add((T) hc);

		return listToReturn;

	}

	/* NEXT HOP ROUTES */
	/**
	 * Add a new HostedRoute association between NexthopRoute and this element
	 * 
	 * @param NextHopRoute
	 * @return
	 */
	public boolean addNextHopRoute(NextHopRoute nextHopRoute) {
		if (nextHopRoute == null)
			return false;
		return (HostedRoute.link(this, nextHopRoute) != null);
	}

	/**
	 * Remove the HostedRoute association (will be deleted) between the NextHopRoute and this element
	 * 
	 * @param protocolEndpoint
	 * @return
	 */
	public boolean removeNextHopRoute(NextHopRoute nextHopRoute) {

		if (nextHopRoute == null)
			return false;
		Association a = this.getToAssociationByElement(nextHopRoute);
		if (a == null)
			return false;
		else {
			a.unlink();
			return true;
		}
	}

	@SuppressWarnings("unchecked")
	public List<NextHopRoute> getNextHopRoute() {
		return (List<NextHopRoute>) this.getToAssociatedElementsByType(HostedRoute.class);
	}

	/**
	 * Remove all NexthopRoute elements
	 * 
	 * @return
	 */
	public boolean removeAllNextHopRoutes() {
		List<NextHopRoute> list = getNextHopRoute();

		boolean oneRemoved = false;

		for (NextHopRoute nhr : list) {
			if (removeNextHopRoute(nhr)) {
				oneRemoved = true;
			}
		}

		return oneRemoved;
	}

	/* LOGICAL DEVICES */
	public boolean addLogicalDevice(LogicalDevice logicalDevice) {
		if (logicalDevice == null)
			return false;
		return (SystemDevice.link(this, logicalDevice) != null);
	}

	public boolean removeAllLogicalDeviceByType(Class<? extends ManagedElement> clazz) {
		List<LogicalDevice> list = getLogicalDevices();

		boolean oneRemoved = false;

		for (LogicalDevice ld : list) {

			if (clazz.isInstance(ld)) {
				if (removeLogicalDevice(ld)) {
					oneRemoved = true;
				}
			}
		}

		return oneRemoved;
	}

	public boolean removeLogicalDevice(LogicalDevice logicalDevice) {

		if (logicalDevice == null)
			return false;
		Association a = this.getToAssociationByElement(logicalDevice);
		if (a == null)
			return false;
		else {
			a.unlink();
			return true;
		}
	}

	@SuppressWarnings("unchecked")
	public List<LogicalDevice> getLogicalDevices() {
		return (List<LogicalDevice>) this.getToAssociatedElementsByType(SystemDevice.class);
	}

	/**
	 * Add a new SystemComponent association between managedSystemElement and this element
	 * 
	 * @param managedSystemElement
	 * @return
	 */
	public boolean addManagedSystemElement(ManagedSystemElement managedSystemElement) {
		if (managedSystemElement == null)
			return false;
		return (SystemComponent.link(this, managedSystemElement) != null);
	}

	/**
	 * Remove the SystemComponent association (will be deleted) between the managedSystemElement and this element
	 * 
	 * @param managedSystemElement
	 * @return
	 */
	public boolean removeManagedSystemElement(ManagedSystemElement managedSystemElement) {

		if (managedSystemElement == null)
			return false;
		Association a = this.getToAssociationByElement(managedSystemElement);
		if (a == null)
			return false;
		else {
			a.unlink();
			return true;
		}
	}

	// TODO control the return value
	public boolean removeAllremoveManagedSystemElementByType(Class<? extends ManagedElement> clazz) {
		List<ManagedSystemElement> list = getManagedSystemElements();

		for (ManagedSystemElement ld : list) {

			if (clazz.isInstance(ld)) {
				removeManagedSystemElement(ld);
			}
		}

		return true;
	}

	/**
	 * This method returns the list of ManagedSystemElement from the toAssociation vector that match with the type SystemComponent the association
	 * wouldn't be deleted
	 * 
	 * @return List<ManagedSystemElement>
	 */
	@SuppressWarnings("unchecked")
	public List<ManagedSystemElement> getManagedSystemElements() {
		return (List<ManagedSystemElement>) this.getToAssociatedElementsByType(SystemComponent.class);
	}

	/**
	 * This constructor creates a SystemBeanImpl Class which implements the SystemBean Interface, and encapsulates the CIM class System in a Java
	 * Bean. The CIM class System is described as follows:
	 * 
	 * CIM_System represents an entity made up of component parts (defined by the SystemComponent relationship), that operates as a 'functional
	 * whole'. Systems are top-level objects in the CIM hierarchy, requiring no scoping or weak relationships in order to exist and have context. It
	 * should be reasonable to uniquely name and manage a System at an enterprise level. For example, a ComputerSystem is a kind of System that can be
	 * uniquely named and independently managed in an enterprise. However, these qualities are not true for the power supply (or the power supply
	 * sub-'system') within the computer. Although a System can be viewed as a Collection, this view is not the correct model. A Collection is simply
	 * a 'bag' that 'holds' its members. A System is a higher-level abstraction, built out of its individual components. It is more than the sum of
	 * its parts. Note that System is a subclass of EnabledLogicalElement which allows the entire abstraction to be functionally enabled or disabled
	 * at a higher level than enabling or disabling its component parts.
	 */
	protected System() {
	};

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property creationClassName.
	 */
	private String	creationClassName;

	/**
	 * This method returns the System.creationClassName property value. This property is described as follows:
	 * 
	 * CreationClassName indicates the name of the class or the subclass used in the creation of an instance. When used with the other key properties
	 * of this class, this property allows all instances of this class and its subclasses to be uniquely identified.
	 * 
	 * @return String current creationClassName property value
	 * @exception Exception
	 */
	public String getCreationClassName() {

		return this.creationClassName;
	} // getCreationClassName

	/**
	 * This method sets the System.creationClassName property value. This property is described as follows:
	 * 
	 * CreationClassName indicates the name of the class or the subclass used in the creation of an instance. When used with the other key properties
	 * of this class, this property allows all instances of this class and its subclasses to be uniquely identified.
	 * 
	 * @param String
	 *            new creationClassName property value
	 * @exception Exception
	 */
	public void setCreationClassName(String creationClassName) {

		this.creationClassName = creationClassName;
	} // setCreationClassName

	// /**
	// * The following constants are defined for use with the ValueMap/Values qualified property name.
	// */
	// private String name;

	/**
	 * This method returns the System.name property value. This property is described as follows:
	 * 
	 * The inherited Name serves as the key of a System instance in an enterprise environment.
	 * 
	 * @return String current name property value
	 * @exception Exception
	 */
	@Override
	public String getName() {
		return super.getName();
	} // getName

	/**
	 * This method sets the System.name property value. This property is described as follows:
	 * 
	 * The inherited Name serves as the key of a System instance in an enterprise environment.
	 * 
	 * @param String
	 *            new name property value
	 * @exception Exception
	 */
	@Override
	public void setName(String name) {
		super.setName(name);
	} // setName

	// /**
	// * The following constants are defined for use with the ValueMap/Values
	// * qualified property nameFormat.
	// */
	// private String nameFormat;
	// /**
	// * This method returns the System.nameFormat property value. This property
	// * is described as follows:
	// *
	// * The System object and its derivatives are top-level objects of CIM.
	// * They provide the scope for numerous components. Having unique System
	// * keys is required. A heuristic can be defined in individual System
	// * subclasses to attempt to always generate the same System Name Key. The
	// * NameFormat property identifies how the System name was generated,
	// * using the heuristic of the subclass.
	// *
	// * @return String current nameFormat property value
	// * @exception Exception
	// */
	// public String getNameFormat(){
	//
	// return this.nameFormat;
	// } // getNameFormat
	//
	// /**
	// * This method sets the System.nameFormat property value. This property is
	// * described as follows:
	// *
	// * The System object and its derivatives are top-level objects of CIM.
	// * They provide the scope for numerous components. Having unique System
	// * keys is required. A heuristic can be defined in individual System
	// * subclasses to attempt to always generate the same System Name Key. The
	// * NameFormat property identifies how the System name was generated,
	// * using the heuristic of the subclass.
	// *
	// * @param String new nameFormat property value
	// * @exception Exception
	// */
	// public void setNameFormat(String nameFormat) {
	//
	// this.nameFormat = nameFormat;
	// } // setNameFormat

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property primaryOwnerName.
	 */
	private String	primaryOwnerName;

	/**
	 * This method returns the System.primaryOwnerName property value. This property is described as follows:
	 * 
	 * The name of the primary system owner. The system owner is the primary user of the system.
	 * 
	 * @return String current primaryOwnerName property value
	 * @exception Exception
	 */
	public String getPrimaryOwnerName() {

		return this.primaryOwnerName;
	} // getPrimaryOwnerName

	/**
	 * This method sets the System.primaryOwnerName property value. This property is described as follows:
	 * 
	 * The name of the primary system owner. The system owner is the primary user of the system.
	 * 
	 * @param String
	 *            new primaryOwnerName property value
	 * @exception Exception
	 */
	public void setPrimaryOwnerName(String primaryOwnerName) {

		this.primaryOwnerName = primaryOwnerName;
	} // setPrimaryOwnerName

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property primaryOwnerContact.
	 */
	private String	primaryOwnerContact;

	/**
	 * This method returns the System.primaryOwnerContact property value. This property is described as follows:
	 * 
	 * A string that provides information on how the primary system owner can be reached (for example, phone number, e-mail address, and so on).
	 * 
	 * @return String current primaryOwnerContact property value
	 * @exception Exception
	 */
	public String getPrimaryOwnerContact() {

		return this.primaryOwnerContact;
	} // getPrimaryOwnerContact

	/**
	 * This method sets the System.primaryOwnerContact property value. This property is described as follows:
	 * 
	 * A string that provides information on how the primary system owner can be reached (for example, phone number, e-mail address, and so on).
	 * 
	 * @param String
	 *            new primaryOwnerContact property value
	 * @exception Exception
	 */
	public void setPrimaryOwnerContact(String primaryOwnerContact) {

		this.primaryOwnerContact = primaryOwnerContact;
	} // setPrimaryOwnerContact

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property roles.
	 */
	private String[]	roles;

	/**
	 * This method returns the System.roles property value. This property is described as follows:
	 * 
	 * An array (bag) of strings that specifies the administrator -defined roles this System plays in the managed environment. Examples might be
	 * 'Building 8 print server' or 'Boise user directories'. A single system may perform multiple roles. Note that the instrumentation view of the
	 * 'roles' of a System is defined by instantiating a specific subclass of System, or by properties in a subclass, or both. For example, the
	 * purpose of a ComputerSystem is defined using the Dedicated and OtherDedicatedDescription properties.
	 * 
	 * @return String[] current roles property value
	 * @exception Exception
	 */
	public String[] getRoles() {

		return this.roles;
	} // getRoles

	/**
	 * This method sets the System.roles property value. This property is described as follows:
	 * 
	 * An array (bag) of strings that specifies the administrator -defined roles this System plays in the managed environment. Examples might be
	 * 'Building 8 print server' or 'Boise user directories'. A single system may perform multiple roles. Note that the instrumentation view of the
	 * 'roles' of a System is defined by instantiating a specific subclass of System, or by properties in a subclass, or both. For example, the
	 * purpose of a ComputerSystem is defined using the Dedicated and OtherDedicatedDescription properties.
	 * 
	 * @param String
	 *            [] new roles property value
	 * @exception Exception
	 */
	public void setRoles(String[] roles) {

		this.roles = roles;
	} // setRoles

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property otherIdentifyingInfo.
	 */
	private String[]	otherIdentifyingInfo;

	/**
	 * This method returns the System.otherIdentifyingInfo property value. This property is described as follows:
	 * 
	 * OtherIdentifyingInfo captures additional data, beyond System Name information, that could be used to identify a ComputerSystem. One example
	 * would be to hold the Fibre Channel World-Wide Name (WWN) of a node. Note that if only the Fibre Channel name is available and is unique (able
	 * to be used as the System key), then this property would be NULL and the WWN would become the System key, its data placed in the Name property.
	 * 
	 * @return String[] current otherIdentifyingInfo property value
	 * @exception Exception
	 */
	public String[] getOtherIdentifyingInfo() {

		return this.otherIdentifyingInfo;
	} // getOtherIdentifyingInfo

	/**
	 * This method sets the System.otherIdentifyingInfo property value. This property is described as follows:
	 * 
	 * OtherIdentifyingInfo captures additional data, beyond System Name information, that could be used to identify a ComputerSystem. One example
	 * would be to hold the Fibre Channel World-Wide Name (WWN) of a node. Note that if only the Fibre Channel name is available and is unique (able
	 * to be used as the System key), then this property would be NULL and the WWN would become the System key, its data placed in the Name property.
	 * 
	 * @param String
	 *            [] new otherIdentifyingInfo property value
	 * @exception Exception
	 */
	public void setOtherIdentifyingInfo(String[] otherIdentifyingInfo) {

		this.otherIdentifyingInfo = otherIdentifyingInfo;
	} // setOtherIdentifyingInfo

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property identifyingDescriptions.
	 */
	private String[]	identifyingDescriptions;

	/**
	 * This method returns the System.identifyingDescriptions property value. This property is described as follows:
	 * 
	 * An array of free-form strings providing explanations and details behind the entries in the OtherIdentifying Info array. Note, each entry of
	 * this array is related to the entry in OtherIdentifyingInfo that is located at the same index.
	 * 
	 * @return String[] current identifyingDescriptions property value
	 * @exception Exception
	 */
	public String[] getIdentifyingDescriptions() {

		return this.identifyingDescriptions;
	} // getIdentifyingDescriptions

	/**
	 * This method sets the System.identifyingDescriptions property value. This property is described as follows:
	 * 
	 * An array of free-form strings providing explanations and details behind the entries in the OtherIdentifying Info array. Note, each entry of
	 * this array is related to the entry in OtherIdentifyingInfo that is located at the same index.
	 * 
	 * @param String
	 *            [] new identifyingDescriptions property value
	 * @exception Exception
	 */
	public void setIdentifyingDescriptions(String[] identifyingDescriptions) {

		this.identifyingDescriptions = identifyingDescriptions;
	} // setIdentifyingDescriptions

} // Class System
