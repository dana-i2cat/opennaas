/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Wed Jan 12
 * 09:21:06 CET 2011.
 */

package org.opennaas.extensions.router.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;

import org.opennaas.core.resources.IModel;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class ManagedElement as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the ManagedElementBean Interface. The CIM class ManagedElement is described as follows:
 * 
 * ManagedElement is an abstract class that provides a common superclass (or top of the inheritance tree) for the non-association classes in the CIM
 * Schema.
 */
public class ManagedElement implements IModel, Serializable {

	/**
	 * These are the associations where I am the "from" element
	 */
	Vector<Association>	toAssociations	= new Vector<Association>();

	/**
	 * Returns the list of Associations where I am the "from" element
	 * 
	 * @return vector of toAssociations
	 */
	public List<Association> getToAssociations() {
		return toAssociations;
	}

	/**
	 * Returns the associations where I am the "from" element, that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return list of Association of toAssociation that match
	 */
	public List<? extends Association> getToAssociationsByType(Class<? extends Association> clazz) {
		List<Association> assocs = new LinkedList<Association>();

		for (Association assoc : toAssociations) {

			if (clazz.isInstance(assoc))
				assocs.add(assoc);
		}

		return assocs;
	}

	/**
	 * Returns the firsts association where I am the "from" element, that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return firsts association of toAssociation that match
	 */
	public Association getFirstToAssociationsByType(Class<? extends Association> clazz) {

		for (Association assoc : toAssociations) {

			if (clazz.isInstance(assoc))
				return assoc;
		}

		return null;
	}

	/**
	 * Returns the list of ManagedElement that represents the "to" of the toAssociations, that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return list of ManagedElement that represents the "to" of the toAssociations
	 */

	public List<? extends ManagedElement> getToAssociatedElementsByType(Class<? extends Association> clazz) {
		List<ManagedElement> elements = new LinkedList<ManagedElement>();
		for (Association assoc : toAssociations) {

			if (clazz.isInstance(assoc))
				elements.add(assoc.getTo());
		}

		return elements;
	}

	/**
	 * Returns the firsts ManagedElement that represents the "to" of the toAssociations that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return ManagedElement that represents the "to" of the toAssociations
	 */
	public ManagedElement getFisrtsToAssociatedElementByType(Class<? extends Association> clazz) {
		ManagedElement element = null;

		for (Association assoc : toAssociations) {
			if (clazz.isInstance(assoc))
				return assoc.getTo();
		}

		return element;
	}

	/**
	 * Returns the firsts Association from toAssociations that have the ManagedElement element as "to" element
	 * 
	 * @param element
	 *            that represents the "to"
	 * @return Association that have I as a "from" and the element as "to"
	 */
	public Association getToAssociationByElement(ManagedElement element) {
		for (Association assoc : toAssociations)
			if (assoc.getTo().equals(element))
				return assoc;

		return null;
	}

	/**
	 * Returns the firsts Association from toAssociations that matches with association type and have the ManagedElement element as "to" element
	 * 
	 * @param clazz
	 *            specific Association.class
	 * @param element
	 *            that represents the "to"
	 * @return Association of type clazz that have I as a "from" and the element as "to"
	 */
	public Association getFirstToAssociationByTypeAndElement(Class<? extends Association> clazz, ManagedElement element) {
		for (Association assoc : toAssociations)
			if (clazz.isInstance(assoc))
				if (assoc.getTo().equals(element))
					return assoc;

		return null;
	}

	/**
	 * Returns the firsts ManagedElement that represents the "to" of the toAssociations that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return ManagedElement that represents the "to" of the toAssociations
	 */
	public ManagedElement getFirstToAssociatedElementByType(Class<? extends Association> clazz) {
		ManagedElement element = null;

		for (Association assoc : toAssociations) {
			if (clazz.isInstance(assoc))
				return assoc.getTo();
		}

		return element;

	}

	/**
	 * 
	 * Add a new association to the vector toAssociation
	 * 
	 * @param the
	 *            association to add
	 * 
	 * */
	public void addToAssociation(Association assoc) {
		toAssociations.add(assoc);
	}

	/**
	 * 
	 * remove the specific association from the vector toAssociation
	 * 
	 * @param the
	 *            association to remove
	 * @return true if association is removed from the vector, false otherwise
	 * */
	public boolean removeToAssociation(Association assoc) {
		return toAssociations.remove(assoc);
	}

	/**
	 * 
	 * remove the specific association from the vector toAssociation that
	 * 
	 * have the ManagedElement element as a "to"
	 * 
	 * @param the
	 *            ManagedElement that represents the "to" into the Association
	 * 
	 * @return true if association is removed from the vector, false otherwise
	 * */
	public boolean removeToAssociationByElement(ManagedElement element) {
		for (Association assoc : toAssociations)
			if (assoc.getTo().equals(element)) {
				return removeToAssociation(assoc);
			}
		return false;
	}

	/**
	 * 
	 * remove the specific association from the vector toAssociation that
	 * 
	 * have the ManagedElement element as a "to"
	 * 
	 * @param the
	 *            ManagedElement that represents the "to" into the Association
	 * 
	 * @return true if association is removed from the vector, false otherwise
	 * */
	public boolean removeToAssociationByTypeAndElement(Class<? extends Association> clazz, ManagedElement element) {
		Association assoc = getFirstToAssociationByTypeAndElement(clazz, element);
		if (assoc == null)
			return false;
		return removeToAssociation(assoc);
	}

	/**
	 * These are the associations where I am the "to" element
	 */
	Vector<Association>	fromAssociations	= new Vector<Association>();

	/**
	 * Returns the list of Associations where I am the "to" element
	 * 
	 * @return vector of fromAssociations
	 */
	public List<Association> getFromAssociations() {
		return fromAssociations;
	}

	/**
	 * Returns the associations where I am the "to" element, that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return list of Association of fromAssociation that match
	 */
	public List<? extends Association> getFromAssociationsByType(Class<? extends Association> clazz) {
		List<Association> assocs = new LinkedList<Association>();

		for (Association assoc : fromAssociations) {
			if (clazz.isInstance(assoc))
				assocs.add(assoc);
		}

		return assocs;
	}

	/**
	 * Returns the firsts association where I am the "to" element, that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return firsts association of fromAssociation that match
	 */
	public Association getFirstFromAssociationsByType(Class<? extends Association> clazz) {

		for (Association assoc : fromAssociations) {
			if (clazz.isInstance(assoc))
				return assoc;
		}

		return null;
	}

	/**
	 * Returns the list of ManagedElement that represents the "from" of the fromAssociations, that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return list of ManagedElement that represents the "from" of the fromAssociations
	 */
	public List<? extends ManagedElement> getFromAssociatedElementsByType(Class<? extends Association> clazz) {
		List<ManagedElement> elements = new LinkedList<ManagedElement>();

		for (Association assoc : fromAssociations) {
			if (clazz.isInstance(assoc))
				elements.add(assoc.getFrom());
		}

		return elements;
	}

	/**
	 * Returns the firsts ManagedElement that represents the "from" of the fromAssociations that match with association type
	 * 
	 * @param specific
	 *            Association.class
	 * @return ManagedElement that represents the "from" of the fromAssociations
	 */
	public ManagedElement getFirstFromAssociatedElementByType(Class<? extends Association> clazz) {

		ManagedElement element = null;

		for (Association assoc : fromAssociations) {
			if (clazz.isInstance(assoc))
				return assoc.getFrom();
		}

		return element;
	}

	/**
	 * Returns the firsts Association from fromAssociations that have the ManagedElement element as "from" element
	 * 
	 * @param element
	 *            that represents the "from"
	 * @return Association that have I as a "to" and the element as "from"
	 */

	public Association getFromAssociationByElement(ManagedElement element) {
		for (Association assoc : fromAssociations)
			if (assoc.getFrom().equals(element))
				return assoc;

		return null;
	}

	/**
	 * Returns the firsts Association from fromAssociations that matches with association type and have the ManagedElement element as "from" element
	 * 
	 * @param clazz
	 *            specific Association.class
	 * @param element
	 *            that represents the "from"
	 * @return Association of type clazz that have I as a "to" and the element as "from"
	 */
	public Association getFirstFromAssociationByTypeAndElement(Class<? extends Association> clazz, ManagedElement element) {
		for (Association assoc : fromAssociations)
			if (clazz.isInstance(assoc))
				if (assoc.getFrom().equals(element))
					return assoc;

		return null;
	}

	/**
	 * 
	 * Add a new association to the vector fromAssociation
	 * 
	 * @param the
	 *            association to add
	 * 
	 * */
	public void addFromAssociation(Association assoc) {
		fromAssociations.add(assoc);
	}

	/**
	 * 
	 * remove the specific association from the vector toAssociation
	 * 
	 * @param the
	 *            association to remove
	 * @return true if association is removed from the vector, false otherwise
	 * */
	public boolean removeFromAssociation(Association assoc) {
		return fromAssociations.remove(assoc);
	}

	/**
	 * 
	 * remove the specific association from the vector fromAssociation that
	 * 
	 * have the ManagedElement element as a "from"
	 * 
	 * @param the
	 *            ManagedElement that represents the "from" into the Association
	 * 
	 * @return true if association is removed from the vector, false otherwise
	 * */
	public boolean removeFromAssociationByElement(ManagedElement element) {
		for (Association assoc : fromAssociations)
			if (assoc.getFrom().equals(element)) {
				return removeFromAssociation(assoc);
			}
		return false;
	}

	/**
	 * This constructor creates a ManagedElementBeanImpl Class which implements the ManagedElementBean Interface, and encapsulates the CIM class
	 * ManagedElement in a Java Bean. The CIM class ManagedElement is described as follows:
	 * 
	 * ManagedElement is an abstract class that provides a common superclass (or top of the inheritance tree) for the non-association classes in the
	 * CIM Schema.
	 */
	protected ManagedElement() {
	};

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property instanceID.
	 */
	private String	instanceID;

	/**
	 * This method returns the ManagedElement.instanceID property value. This property is described as follows:
	 * 
	 * InstanceID is an optional property that may be used to opaquely and uniquely identify an instance of this class within the scope of the
	 * instantiating Namespace. Various subclasses of this class may override this property to make it required, or a key. Such subclasses may also
	 * modify the preferred algorithms for ensuring uniqueness that are defined below. To ensure uniqueness within the NameSpace, the value of
	 * InstanceID should be constructed using the following "preferred" algorithm: <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a
	 * colon (:), and where <OrgID> must include a copyrighted, trademarked, or otherwise unique name that is owned by the business entity that is
	 * creating or defining the InstanceID or that is a registered ID assigned to the business entity by a recognized global authority. (This
	 * requirement is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure uniqueness, <OrgID> must not
	 * contain a colon (:). When using this algorithm, the first colon to appear in InstanceID must appear between <OrgID> and <LocalID>. <LocalID> is
	 * chosen by the business entity and should not be reused to identify different underlying (real-world) elements. If not null and the above
	 * "preferred" algorithm is not used, the defining entity must assure that the resulting InstanceID is not reused across any InstanceIDs produced
	 * by this or other providers for the NameSpace of this instance. If not set to null for DMTF-defined instances, the "preferred" algorithm must be
	 * used with the <OrgID> set to CIM.
	 * 
	 * @return String current instanceID property value
	 * @exception Exception
	 */
	public String getInstanceID() {

		return this.instanceID;
	} // getInstanceID

	/**
	 * This method sets the ManagedElement.instanceID property value. This property is described as follows:
	 * 
	 * InstanceID is an optional property that may be used to opaquely and uniquely identify an instance of this class within the scope of the
	 * instantiating Namespace. Various subclasses of this class may override this property to make it required, or a key. Such subclasses may also
	 * modify the preferred algorithms for ensuring uniqueness that are defined below. To ensure uniqueness within the NameSpace, the value of
	 * InstanceID should be constructed using the following "preferred" algorithm: <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a
	 * colon (:), and where <OrgID> must include a copyrighted, trademarked, or otherwise unique name that is owned by the business entity that is
	 * creating or defining the InstanceID or that is a registered ID assigned to the business entity by a recognized global authority. (This
	 * requirement is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure uniqueness, <OrgID> must not
	 * contain a colon (:). When using this algorithm, the first colon to appear in InstanceID must appear between <OrgID> and <LocalID>. <LocalID> is
	 * chosen by the business entity and should not be reused to identify different underlying (real-world) elements. If not null and the above
	 * "preferred" algorithm is not used, the defining entity must assure that the resulting InstanceID is not reused across any InstanceIDs produced
	 * by this or other providers for the NameSpace of this instance. If not set to null for DMTF-defined instances, the "preferred" algorithm must be
	 * used with the <OrgID> set to CIM.
	 * 
	 * @param String
	 *            new instanceID property value
	 * @exception Exception
	 */
	public void setInstanceID(String instanceID) {

		this.instanceID = instanceID;
	} // setInstanceID

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property caption.
	 */
	private String	caption;

	/**
	 * This method returns the ManagedElement.caption property value. This property is described as follows:
	 * 
	 * The Caption property is a short textual description (one- line string) of the object.
	 * 
	 * @return String current caption property value
	 * @exception Exception
	 */
	public String getCaption() {

		return this.caption;
	} // getCaption

	/**
	 * This method sets the ManagedElement.caption property value. This property is described as follows:
	 * 
	 * The Caption property is a short textual description (one- line string) of the object.
	 * 
	 * @param String
	 *            new caption property value
	 * @exception Exception
	 */
	public void setCaption(String caption) {

		this.caption = caption;
	} // setCaption

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property description.
	 */
	private String	description;

	/**
	 * This method returns the ManagedElement.description property value. This property is described as follows:
	 * 
	 * The Description property provides a textual description of the object.
	 * 
	 * @return String current description property value
	 * @exception Exception
	 */
	public String getDescription() {

		return this.description;
	} // getDescription

	/**
	 * This method sets the ManagedElement.description property value. This property is described as follows:
	 * 
	 * The Description property provides a textual description of the object.
	 * 
	 * @param String
	 *            new description property value
	 * @exception Exception
	 */
	public void setDescription(String description) {

		this.description = description;
	} // setDescription

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property elementName.
	 */
	private String	elementName;

	/**
	 * This method returns the ManagedElement.elementName property value. This property is described as follows:
	 * 
	 * A user-friendly name for the object. This property allows each instance to define a user-friendly name in addition to its key properties,
	 * identity data, and description information. Note that the Name property of ManagedSystemElement is also defined as a user-friendly name. But,
	 * it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user-friendly name, without
	 * inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information can be present in both the
	 * Name and ElementName properties. Note that if there is an associated instance of CIM_EnabledLogicalElementCapabilities, restrictions on this
	 * properties may exist as defined in ElementNameMask and MaxElementNameLen properties defined in that class.
	 * 
	 * @return String current elementName property value
	 * @exception Exception
	 */
	public String getElementName() {

		return this.elementName;
	} // getElementName

	/**
	 * This method sets the ManagedElement.elementName property value. This property is described as follows:
	 * 
	 * A user-friendly name for the object. This property allows each instance to define a user-friendly name in addition to its key properties,
	 * identity data, and description information. Note that the Name property of ManagedSystemElement is also defined as a user-friendly name. But,
	 * it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user-friendly name, without
	 * inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information can be present in both the
	 * Name and ElementName properties. Note that if there is an associated instance of CIM_EnabledLogicalElementCapabilities, restrictions on this
	 * properties may exist as defined in ElementNameMask and MaxElementNameLen properties defined in that class.
	 * 
	 * @param String
	 *            new elementName property value
	 * @exception Exception
	 */
	public void setElementName(String elementName) {

		this.elementName = elementName;
	} // setElementName

	@Override
	public List<String> getChildren() {

		/* ManagedElement do not include these relations */
		return new ArrayList<String>();
	}

} // Class ManagedElement
