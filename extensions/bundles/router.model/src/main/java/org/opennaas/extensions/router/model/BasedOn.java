/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Wed Jan 12
 * 09:21:06 CET 2011.
 */

package org.opennaas.extensions.router.model;

import java.io.*;
import java.lang.Exception;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class BasedOn as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the BasedOnBean Interface. The CIM class BasedOn is described as follows:
 * 
 * BasedOn is an association describing how StorageExtents can be assembled from lower level Extents. For example, ProtectedSpaceExtents are parts of
 * PhysicalExtents, while VolumeSets are assembled from one or more Physical or ProtectedSpaceExtents. As another example, CacheMemory can be defined
 * independently and realized in a PhysicalElement or can be 'based on' Volatile or NonVolatileStorageExtents.
 */
public class BasedOn extends Dependency implements Serializable {

	/**
	 * This constructor creates a BasedOnBeanImpl Class which implements the BasedOnBean Interface, and encapsulates the CIM class BasedOn in a Java
	 * Bean. The CIM class BasedOn is described as follows:
	 * 
	 * BasedOn is an association describing how StorageExtents can be assembled from lower level Extents. For example, ProtectedSpaceExtents are parts
	 * of PhysicalExtents, while VolumeSets are assembled from one or more Physical or ProtectedSpaceExtents. As another example, CacheMemory can be
	 * defined independently and realized in a PhysicalElement or can be 'based on' Volatile or NonVolatileStorageExtents.
	 */
	public BasedOn() {
	};

	/**
	 * This method create an Association of the type BasedOn between one StorageExtent object and StorageExtent object
	 */
	public static BasedOn link(StorageExtent antecedent, StorageExtent
			dependent) {

		return (BasedOn) Association.link(BasedOn.class, antecedent, dependent);
	}// link

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property startingAddress.
	 */
	private long	startingAddress;

	/**
	 * This method returns the BasedOn.startingAddress property value. This property is described as follows:
	 * 
	 * StartingAddress indicates where in lower level storage, the higher level Extent begins.
	 * 
	 * @return long current startingAddress property value
	 * @exception Exception
	 */
	public long getStartingAddress() {

		return this.startingAddress;
	} // getStartingAddress

	/**
	 * This method sets the BasedOn.startingAddress property value. This property is described as follows:
	 * 
	 * StartingAddress indicates where in lower level storage, the higher level Extent begins.
	 * 
	 * @param long new startingAddress property value
	 * @exception Exception
	 */
	public void setStartingAddress(long startingAddress) {

		this.startingAddress = startingAddress;
	} // setStartingAddress

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property endingAddress.
	 */
	private long	endingAddress;

	/**
	 * This method returns the BasedOn.endingAddress property value. This property is described as follows:
	 * 
	 * EndingAddress indicates where in lower level storage, the higher level Extent ends. This property is useful when mapping non-contiguous Extents
	 * into a higher level grouping.
	 * 
	 * @return long current endingAddress property value
	 * @exception Exception
	 */
	public long getEndingAddress() {

		return this.endingAddress;
	} // getEndingAddress

	/**
	 * This method sets the BasedOn.endingAddress property value. This property is described as follows:
	 * 
	 * EndingAddress indicates where in lower level storage, the higher level Extent ends. This property is useful when mapping non-contiguous Extents
	 * into a higher level grouping.
	 * 
	 * @param long new endingAddress property value
	 * @exception Exception
	 */
	public void setEndingAddress(long endingAddress) {

		this.endingAddress = endingAddress;
	} // setEndingAddress

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property orderIndex.
	 */
	private int	orderIndex;

	/**
	 * This method returns the BasedOn.orderIndex property value. This property is described as follows:
	 * 
	 * If there is an order to the BasedOn associations that describe how a higher level StorageExtent is assembled, the OrderIndex property indicates
	 * this. When an order exists, the instances of BasedOn with the same Dependent value (i.e., the same higher level Extent) should place unique
	 * values in the OrderIndex property. The lowest value implies the first member of the collection of lower level Extents, and increasing values
	 * imply successive members of the collection. If there is no ordered relationship, a value of zero should be specified. An example of the use of
	 * this property is to define a RAID-0 striped array of 3 disks. The resultant RAID array is a StorageExtent that is dependent on (BasedOn) the
	 * StorageExtents that describe each of the 3 disks. The OrderIndex of each BasedOn association from the disk Extents to the RAID array could be
	 * specified as 1, 2 and 3 to indicate the order in which the disk Extents are used to access the RAID data.
	 * 
	 * @return int current orderIndex property value
	 * @exception Exception
	 */
	public int getOrderIndex() {

		return this.orderIndex;
	} // getOrderIndex

	/**
	 * This method sets the BasedOn.orderIndex property value. This property is described as follows:
	 * 
	 * If there is an order to the BasedOn associations that describe how a higher level StorageExtent is assembled, the OrderIndex property indicates
	 * this. When an order exists, the instances of BasedOn with the same Dependent value (i.e., the same higher level Extent) should place unique
	 * values in the OrderIndex property. The lowest value implies the first member of the collection of lower level Extents, and increasing values
	 * imply successive members of the collection. If there is no ordered relationship, a value of zero should be specified. An example of the use of
	 * this property is to define a RAID-0 striped array of 3 disks. The resultant RAID array is a StorageExtent that is dependent on (BasedOn) the
	 * StorageExtents that describe each of the 3 disks. The OrderIndex of each BasedOn association from the disk Extents to the RAID array could be
	 * specified as 1, 2 and 3 to indicate the order in which the disk Extents are used to access the RAID data.
	 * 
	 * @param int new orderIndex property value
	 * @exception Exception
	 */
	public void setOrderIndex(int orderIndex) {

		this.orderIndex = orderIndex;
	} // setOrderIndex

} // Class BasedOn
